# 영단어를 결합한느 방식의 이름

한 가지 더 여러 영단어를 사용할 때의 이름에 관해 소개한다. 'subtitle'이라는 영어를 클래스 이름으로 하고자 하는 경우 다음과 같이 표기법에 관한 고민을 해보았을 것이다.

-   sub-title과 같이 각 단어를 하이픈으로 연결
-   sub_title과 같이 각 단어를 언더스코어로 연결
-   subTitle과 같이 두 번째 이후 영단어의 첫 문자를 대문자로 표기
-   SubTitle과 같이 모든 영단어의 첫 문자를 대문자로 표기

어떤 표기법이 최선인지는 문제는 제쳐 두고(라고 하기보다 결정할 수 없다.) 이들 표기법은 각각의 이름을 갖고 있다. 3장에서 소개할 다양한 설계 기법에서도 각각 다른 표기법을 사용하고 있으며 해당 내용을 설명할 때 이름을 사용한다.

## 표기법 이름

이 표기법의 이름은 CSS 설계에 국한되지 않고 프로그래밍 전반에서 공통적으로 사용하므로 꼭 기억해 두시기 바랍니다.

-   sub-title과 같이 각 단어를 하이픈으로 연결함. -> 하이픈 케이스(케밥 케이스)
-   sub_title과 같이 각 단어를 언더스코어로 연결한다. -> 스네이크 케이스
-   subTitle과 같이 두 번째 이후 영단어의 첫 문자를 대문자로 표기한다. -> 로워 캐멀 케이스
-   SubTitle과 같이 모든 영단어의 첫 문자를 대문자로 표기한다. -> 어퍼 캐멀 케이스

# 2-4 좋은 CSS 설계의 네 가지 목표

그럼 이 책의 본주제인 CSS 설계 이야기로 들어가자. 우선 추상적으로 "좋은 CSS란 무엇인가"에 대해 생각해보자.

이때 도움이 되는 지침이 "좋은 CSS 설계 네 가지 목표"인데, 이는 구글 엔지니어인 필립 왈튼의 그의 블로그에서 제창한 사고방식입니다. 이는 CSS에 조사해 보면 자주 는에 들어오는 유명한 사고방식으로 다음과 같다.

-   에측 가능하다.
-   재사용 가능하다.
-   유지 보수 가능하다.
-   확장 가능하다.

## 예측 가능하다.

"예측 가능하다"란 다시 말해 "스타일링이 기대한 대로 동작하는지", "스타일링 영향 범위를 예측할 수 있는지"를 의미한다. 새로운 스타일링을 추가하거나 기존 스타일링을 업데이트하더라도 자신이 의도하지 않은 위치에 영향을 주지 않아야 한다는 것이다.

작은 웹사이트에서는 그다지 문제가 되지 않을 수도 있다. 수십 페이지 혹은 수백 페이지로 구성된 큰 웹사이트에서 이런 사고방식은 필수이다.

## 재사용 가능하다.

예를 들어, 기존 부품을 다른 위치에서도 사용하고 싶은 경우에 코드를 일일이 다시 작성하거나 덮어쓰지 않아도 "재사용 가능한" 상태를 말한다. 이를 위해서는 스타일링이 확실하게 추상화 되어 있고 적절하게 분리되어 있어야 한다.

"추상화", "분리"라는 표현은 아직 이미지가 그려지지 않을 수도 있다. 뒤에서 소개할 [OOCSS]를 이해하면 '재사용 가능한다"고 부르는 것이 무엇인지 알 수 있을 것이다.

## 유지 보수 가능하다

새로운 모듈이나 기능을 추가, 변경 또는 그 배치를 바꿨을 때 기존 CSS를 리팩터링 필요가 없는 상태가 "유지 보수 가능한" 상태이다. 예를 들어, 모듈 A를 추가했을 때 기존에 있던 모듈 B에 영향을 주어 파괴하는 상황은 바람직하지 않다.

## 확장 가능하다

"확장 가능하다"란 CSS를 다루는 인원 수에 상관하지 않고 문제없이 관리할 수 있는 상태를 의미한다. 이를 위해서는 CSS 설계 규칙을 알기 쉽게 정의하여 학습 비용이 너무 높지 않은 상태여야 한다.

처음엔 한 사람이 개발을 시작했다 하더라도 웹사이트가 커지거나 복잡해지면 CSS를 다루는 사람이 자연히 늘어나는 것이 현대의 개발이다. 그러므로 초반 단계부터 '확장 가능한' 상태의 CSS인지 아닌지 고려해야 한다.

# 2-5 CSS 설계 실전과 여덟 가지 포인트

실제로 앞에서 설명한 "좋은 CSS 설계의 네 가지 목표"를 구현할 때 다양한 시도와 함께 코드를 작성하게 된다. 아무런 지표가 없다면 고려할 것이 너무 많아 골치가 아프다. 사실 그 방법은 다음에 설명할 여덟 가지 중 하나 혹은 그 이상에 해당한다.

이 책에서 소개할 다음 설계 기법들 역시 반드시 여덟 가지 포인트 중 어딘가에 해당하는 규칙을 갖고 있다.

-   OOCSS
-   SMACSS
-   BEM
-   PRECSS

이번 장 이후에도 '이 규칙이나 시도가 여덟 가지 포인트 중 무엇에 해당하는가?'를 짚어볼 예정이니 이 절의 내용은 수시로 확인해볼 것을 권장한다.

1. 특성에 따라 CSS를 분류한다.
2. HTML과 스타일링을 느슨하게 결합한다.
3. 영향 범위를 지나치게 넓히지 않는다.
4. 특정한 콘텍스트에 지나치게 의존하지 않는다.
5. 상세도를 지나치게 높이지 않는다.
6. 클래스 이름에서 영향 범위를 유추할 수 있다.
7. 클래스 이름에서 형태, 기능, 역할을 유추할 수 있다.
8. 확장하기 쉽다.

## 모듈

모듈이란 사이트 안에서의 재사용을 가정해 한 덩어리로 만든 부품으로 '컴포넌트(Component)라고 부른다. CSS 설계에서는 '컴포넌트', '모듈'은 모두 같은 대상을 가리키는 경우가 많다. 이 책에서는 '모듈'로 통일하자.

이 모듈은 다음과 같은 코드로 구현되어 있다고 가정한다.
리셋 CSS는 css-wipe를 사용하는 것을 전제로 한다. 미리 말씀드리면 이 코드는 이상적인 코드는 아니다.(오히려 형편없어서 보고 있으면 기분이 나빠지는 코드이다.) CSS 설계의 여덟 가지 포인트를 소개하고 설명하면서 이 코드를 PRECSS에 맞춰 리팩터링해 간다. PRECSS에 관한 상세한 내용은 3장에서 알아볼 것이다.

지금 단계에선 중요치 않으므로 계속 읽어보자.

## 특성에 따라 CSS를 분류한다.

첫 번째는 CSS 분류에 관한 내용으로 다음과 같이 CSS역할이나 특성에 따라 그룹을 나누는 것이다.

-   예를 들어, 리셋 CSS나 링크 텍스트는 빨간색으로 한다 = a { color : red}'와 같이 사이트 전체에 기반이 되는 베이스 스타일을 '베이스 그룹'으로 만든다.
-   헤어나 푸터 그리고 콘텐츠 영역을 형성하는 스타일링을 '레이아웃 그룹'으로 만든다.

각 설계 기법은 다음 3장에서 자세하게 설명한다. 이 기법은 SMACSS, PRECSS에서 채용하고 있다. 또한 이 분류의 모듈 이름에 추가적으로 접두사를 붙이면 어떤 분류에 해당하는지 눈으로 확인할 수 있다. 예를 들어, 레이아웃과 관련한 코드에 대해 SMACSS에서는 '-l', PRECSS에선 'ly*'라는 접두사를 붙인다. PRECSS에서는 모듈 분류 시 'el*', 'bl\_'과 같은 접두사를 사용한다.

```css
#main div.module.main-module {
    /*좌우 가운데 정렬을 위한 지정*/
    max-width: 1200px;
    padding-right: 15px;
    padding-left: 15px;
    margin-right: auto;
    margin-left: auto;
    /* 모듈에 대한 지정 */
    display: flex;
    align-items: center;
    font-family: sans-serif
    font-size: 16px;
    line-height: 1.5;
}
```

베이스 폰트를 지정한 CSS이다. 베이스 폰트는 기본적으로 이 모듈에만 국한되지 않으며 사이트 전체에 공통으로 적용된다. 새로운 모듈을 만들 때마다 폰트를 지정하는 것은 매우 번거로운 작업이다. 여기에서는 고딕체(sans-serif)를 지정했지만, '사이트 전체의 글씨체를 명조체로 하고 싶다'와 같은 경우에도 모듈 지정한다면 수정할 위치가 많아진다. 따라서 폰트 지정 등은 모듈이 아니라 body 요소에 적용하도록 한다.

```css
body {
    font-family: sans-serif;
}
```

이외에도 '사이트 내 공통으로 적용할 것', '사이트 베이스로 하면 좋을 만한 것'은 베이스 그룹에 해당한다. 예를 들어, 반응형 디자인(Responsive Design)을 구성하는 요소의 하나인 프루이드 이미지(Fluid Image) 코드 등도 베이스 그룹이라 할 수 있습니다. 즉, 요소형 셀렉터를 사용해서 스타일링 하는 것들이다.

```css
img {
    max-width: 100%;
    height: auto;
}
```

### 레이아웃 그룹 정의

```css
main div.module.main-module {
    /* 좌우 가운데 정렬을 위한 설정, 이 코드를 주목 */
    max-width: 1200px;
    padding-right: 15px;
    padding-left: 15px;
    margin-right: auto;
    margin-left: auto;
    /* 모듈을 위한 지정 */
    display: flex;
    align-items: sans-serif;
    font-family: 16px;
    font-size: 16px;
    line-height: 1.5;
}
```

이 코드들을 그림 2-8과 같이 콘텐츠 영역에 대해 모듈을 최대 폭인 1200px에서 좌우 가운데 정렬로 배치하기 위한 코드이다.

이후 다른 모듈을 추가해도 모두 좌우 가운데 정렬로 1200px의 콘텐츠 내에 들어가면 좋을 것이다. 그때마다 모듈별로 max-width와 padding-right, padding-left, margin-right, margin-left를 설정하는 것은 많은 수고가 들뿐더러 번거롭고 불필요한 작업이기도 하다. 따라서 이들 속성은 레이아웃 그룹, 즉 "주로 위치 조정을 담당하는 코드"로 분리한다.

이를 위해 레이아웃과 관련한 것을 담당하기 위한 클래스로 'ly*cont'를 새롭게 만들고, 모듈이 아닌 한 단계 상위의 콘텐츠 영역 전체를 활용하는 article 요소에 클래스를 추가한다. 'ly*'는 레이아웃 그룹에 있다는 것을 의미하는 접두사다.

```html
<article id="main" class="ly_cont">
    <!-- ly_cont를 추가 -->
    <div class="module main-module">(생략)</div>
</article>
```

```css
.ly_cont {
    max-width: 1200px;
    padding-right: 15px;
    padding-left: 15px;
    margin-right: auto;
    margin-left: auto;
}
#main div.module.main-module {
    display: flex;
    align-items: center;
    font-size: 16px;
    line-height: 1.5;
}
```

이후에는 콘텐츠 영역을 정의하기 위한 max-width와 padding-right, padding-left, margin-right, margin-left를 매번 설정할 필요가 없으며, 콘텐츠 영역이 1200px에서 변경된 경우에도 ly*cont만 수정하면 된다. 또한 'ly*' 접두사를 사용해서 HTML을 보기만 해도 '이 클래스가 레이아웃을 담당하고 있음'을 한 눈에 알 수 있다.

### 모듈 그룹 정의

모듈 그룹은 사이트 전체에서 재사용하는 것을 가정하고 있으므로 한 눈에 쉽게 들어오도록 모듈 이름 'bl\_'이라는 접두사를 붙인다.

```html
<div class="bl_module main-module">
    <!-- bl_이라는 접두사를 붙인다. -->
</div>
```

이를 통해 "bl\_이 붙어 있는 것은 모듈 그룹이며 어떠한 페이지에서도 재사용할 수 있다"는 것을 확인할 수 있다.

### 리팩터링 후의 코드

코드를 분류한 것 만으로도 코드가 보다 깔끔해졌다. 뿐만 아니라 다음과 같이 적절하게 분류하면 이후에 발생할 요구 사항이나 수정에도 쉽게 대응할 수 있다.

-   베이스 그룹: 사이트 전체에 적용해야 할 스타일은 베이스 그룹
-   레이아웃 그룹: 레이아웃과 관련 있는 스타일은 레이아웃 그룹
-   모듈 그룹: 사이트 내 페이지들에서 재사용할 수 있는 것은 모듈 그룹

### 모듈에 대한 레이아웃 지정

지금까지 진행한 것처럼 기본적으로 모듈 자체에는 레이아웃과 관련된 지정은 하지 않는 것이 좋다. '레이아웃과 관련된 지정'이란 구체적으로 다음 항목 등을 가리킨다.

[레이아웃과_관련된_지정]

-   position
-   z-index
-   top / right / bottom / left
-   float
-   width
-   margin

모듈 자체에 이 값들을 지적접 지정하지 않음으로써 모듈들은 블록 레벨 요소의 특성에 따라 부모 요소의 가로 폭 100%를 채우게 되고, 여러 모듈을 세로로 배치하는 경우에는 상하 여백없이 붙은 상태가 된다. 이 상태에서는 어떤 위치에서 모듈을 사용하더라도 모양이 깨지지 않으며, 레이아웃과 관련한 스타일을 무시하기 위해 CSS 코드를 작성하지 않다도 되므로 재 사용성이 매우 높다.

하지만 현실적으로 모듈 사이 위아래 여백을 일일이 설정하는 것은 번거로울 수도 있다. 그래서 margin-top / margin-bottom 정도는 모듈 자체에 포함시켜도 좋을 것이다. -> 7장 참고.

모듈에 대한 레이아웃과 관련한 지정에 대해 다소 어려운 이야기를 해보면 '모듈은 해당 모듈 자체에 관한 처리 및 처리 요소의 스타일링에만 관심을 가져야 하며, '자신이 어디에 어떤 크기로 배치되어야 하는가?'에 관해서는 레이아웃 그룹 혹은 모듈을 사용하는 콘텍스트에 맡긴다'고 할 수 있다.

조금 어려운 내용이기는 하나 지금은 전부 이해하지 않아도 괜찮다. 다만 '모듈 자체에는 레이아웃과 관련된 지정을 하지 않는다'는 내용이 책 중간중간 등장하므로 그 때는 이번 장의 설명을 다시 읽어 보면서 조금씩 이해를 높여 가길 바란다.

[컨텍스트]
앞에서 언급한 '장소, 상황'이라는 단어는 보통 '콘텍스트(직역하면 '문맥')'라고 불린다. 이 '콘텍스트'라는 용어는 CSS 설계뿐만 아니라 다른 프로그래밍 용어에서도 자주 사용하므로 기억해두자.

## HTML과 스타일링을 느슨하게 결합한다.

다음 포인트는 'HTML과 스타일링을 느슨하게 결합한다.'이다. 느슨한 결합이라는 용어가 조금 낯설지도 모르겠다. 이는 의미상 'HTML과의 결합이 강하지 않다' 또는 'HTML에 의존하지 않는다' 등으로 표현할 수 있다. 반대로 HTML에 강하게 결합한, 다시 말해 의존하는 상태를 'HTML과 밀접하게 결합해 있다'고 말한다.

-   '밀접한 결합/느슨한 결합'이라는 말은 CSS 설계에만 국한한 것이 아니라 프로그래밍 전방에서 자주 사용하는 표현

HTML과 스타일링을 느슨하게 결합하는 것이 좋은 이유?

<그림\_2-9> h2 요소를 사용한 위치에 주목하자.
모듈은 다양한 페이지에서의 재사용을 전제로 하고 있다. 하지만 제목 요소는 문서 구조에 영향을 미치며, 사용되는 페이지, 위치 혹은 상황에 따라 h3 혹은 h4로 설정해야 할 때가 있다. 이런 변경에도 대응할 수 있는 간단한 방법으로 다음 코드와 같이 그룹 셀렉터를 사용할 수 있다.

````css
#main div.bl_module.main-module h2,
#main div.bl_module.main-module h3,
#main div.bl_module.main-module h4 {
    margin-bottom: 10px;
    font-size: 18px,
    font-weight: bold;
}

그러나 이 코드를 사용하면 h3 스타일이 보통 굵기의 텍스트로 표시될 것이라는 예상과 달리 그림 2-10과 같이 '퍼소나란?' 위치가 굵게 표시된다.

이는 다음 코드와 같이 h3 요소에 대해 스타일링이 중복되기 때문이다.

```css
#main div.blmodule.main-module h2,
#main div.blmodule.main-module h3,
#main div.blmodule.main-module h4 {
    margin-bottom: 10px;
    font-size 18px;
    font-weight: bold; /* 이 스타일링이 '퍼소나란? 에 적용되어 버림 */
}
#main div.bl_module.main-module h3 {
    margin-top: 10px;
    margin-bottom: 10px;
    font-size: 16px;
    border-bottom: 1px solid #555;
}
````

'퍼소나란?'은 h3, h4 양쪽 모두가 될 수 있기 때문에 같은 방법으로는 셀렉터를 h4만으로 할 수동 없다. 요소형 셀렉터를 사용하는 한, 이런 복잡하고 번거로운 문제는 항상 따라다닌다.

이 문제는 간단하게 해결할 수 있다. '요소형 셀렉터를 사용하지 않는다.' 다시 말해 'HTML과 스타일링을 약하게 연결(=느슨하게 결합)'하면 된다. 예를 들면, '사용자를 고려한~'에는 'title'이라는 클래스 이름, '퍼소나란?'에는 'sub-title'이라는 클래스 이름의 클래스 셀렉터를 사용하면 이 문제를 간단히 회피할 수 있다.

```html
<article id="main" class="ly_cont">
    <div class="bl_module main module">
        <h2 class="title">사용자를 고려한 설계로 만족스러운 체험을</h2>
        <h3 class="sub-title">퍼소나란?</h3>
    </div>
</article>
```

```css
#main div.bl_module.main-module .title {
    margin-bottom: 10px;
    font-size: 18px;
    font-weight: bold;
}
#main div.bl_module.main-module .sub-title {
    margin-top: 10px;
    margin-bottom: 10px;
    font-size: 16px;
    border-bottom: 1px solid #555;
}
```

이제 각 제목은 어떤 레벨이든 스타일링이 섞이지 않는다. 제목 요소 뿐만 아니라 다른 요소들에 대해서도 HTML 요소 이름은 가급적 셀렉터로 사용하지 않는 것이 최선의 선택이다. 예를 들어, 지금까지 div 요소였던 것이 무언가의 이유로 p 요소로 바뀌면 div 요소에 설정했던 스타일이 적용되지 않기 떄문이다. 따라서 각 셀렉터에'#main div.bl_module.main-module'이라고 되어 있는 코드에서 'div'를 잘라 낸다.

이는 '5. 상세도를 지나치게 높이지 않는다'와도 연결된다.

### 리팩터링 후의 코드

지금까지 설명한 내용을 포함해 모듈 내 요소에 대한 스타일링을 전체적으로 클래스 셀렉터를 사용한 방법으로 변경한 코드를 실었따. 현실적으로 모든 요소에 클래스를 정하는 것은 상당한 노력이 드는 작업이기도 하다. 예를 들어, 다음 코드의 '#main .bl_module.main-module .image-wrapper img{}` 셀렉터와 같이 어느 정도 범위가 교차하는 요소에 관해서는 HTML 요소 이름을 그대로 사용해도 큰 지장은 없다. 단, div 요소나 p 요소, span 요소는 모듈 내에서 자주 사용하므로, 이들에 대해서는 확실히 클래스 이름을 설정해 두면, 나중에 모듈을 개선할 필요가 발생했을 때 유용하게 사용할 수 있다.
('#main span'은 '3. 영향을 지나치게 넓히지 않는다'에서 설명하기 위해 현재 상태를 유지했다.)

```html
<article id="main" class="ly_cont">
    <div class="bl_mdoule main-module">
        <figure class="image-wrapper">
            <img src="#" alt="사진: 손에 든 스마트폰" />
        </figure>
        <div class="body">
            <h2 class="title">사용자를 고려한 설계로 만족스러운 체험을</h2>
            <p>
                웹사이트 설계는 제공하는 서비스나 퍼소나에 따라 달라집니다.
                서비스와 퍼소나에 맞춘 설계를 통해 방문자에게 스트레스를 주지
                않는 보다 나은 체험을 만들어 만족감을 높입니다. <br />
                우리는 고객의 사이트에 맞는 사용성을 고려하기 때문에 세심한
                분석과 의견 청취를 실시함으로써, 만족을 체험할 수 있는
                크리에이티브 및 테크놀로지를 설계하고 구현함으로써 지금까지는
                없던 기대를 뛰어넘는 사용자 체험을 제공합니다.
            </p>
            <h3 class="sub-title">퍼소나란?</h3>
            <span>
                자사 상품, 서비스의 이상적/ 상징적인 고객 이미지를 말합니다.
                접근할 대상을 명확히 함으로써 효율적인 마케팅을 수행할 수
                있습니다.
            </span>
        </div>
    </div>
</article>
```

```css
/* 베이스, 레이아웃은 변경이 없으므로 생략합니다. */

/* 모듈
======================================== */
#main span {
    color: #555;
    font-size: 14px;
}
#main .bl_module.main-module {
    display: flex;
    align-items: center;
    font-size: 16px;
    line-height: 1.5;
}
#main .bl_module.main-module .image-wrapper {
    flex: 1 1 25%;
    margin-right: 3.33333%;
}
#main .bl_module.main-module .image-wrapper img {
    width: 100%;
    vertical-align: top;
}
#main .bl_module.main-module .body {
    flex: 1 1 68.33333%;
}
#main .bl_module.main-module .title {
    margin-bottom: 10px;
    font-size: 18px;
    font-weight: bold;
}
#main .bl_module.main-module .subtitle {
    margin-top: 10px;
    margin-bottom: 10px;
    font-size: 16px;
    border-bottom: 1px solid #555;
}
```

HTML과 스타일링을 느슨하게 결합하는 것은 "좋은 CSS 설계의 네 가지 목표"에서 소개한 "재사용 가능하다", "유지 보수 가능하다"와도 이어진다.

### HTML과 스타일링을 밀접하게 결합한 패턴

지금까지의 모듈과는 관계가 없지만, HTML과 스타일링을 밀접하게(강하게) 결합한 패턴을 하나 확인해보자.

```css
a[href="google.co.kr"] {
    color: red;
}
```

이 스타일링은 "링크 대상이 https://google.co.kr이라면 문자 색상을 빨간생그로 한다"는 것을 의미한다. 하지만 뒤엇 'http://www.naver.com의 경우에도 빨갛게 하고 싶다'는 추가 요청이 있다면 어떻게 해야 할까?

단순하게 생각하면 다음과 같이 그룹 셀렉터를 사용해 대응할 수 있다.

```css
a[href="google.co.kr"],
a[href="naver.com"] {
    color: red;
}
```

이런 추가 요청이 있을 떄마다 CSS에 해당 내용을 추가하는 것은 번거롭다. 속성 셀렉터를 사용하거나 또는 '특정한 문자열을 가진 경우(링크 대상이 구글 혹인 네이버인 경우)'에는 그룹 셀럭터의 코드를 늘리지 않는 한 다른 문자열 색상을 빨간색으로 하고 싶은 패턴에 대응할 수 없다.

그런고로 속성 셀렉터의 특정값을 사용한 스타일링 또한 기본적으로 피해야 한다.

## 영향 범위를 지나치게 넓히지 않는다.

다음 포인트는 '영향 범위를 지나치게 넓히지 않는다'이다. 여기에서는 [지나치게]라는 점이 핵심이며, 확실하게 계산한 결과 영향 범위가 넓은 CSS를 사용한 것이라면 그다지 큰 문제는 없다. 베이스 그룹의 코드 등이 이에 해당한다.

그러나 영향 범위가 넓은 CSS에 불필요한 스타일링 등을 포함하면 상황이 매우 힘들어진다. 새로운 모듈을 만들 때 불필요한 스타일링을 비활성화하는 코드를 작성해야만 하고, 영향 범위가 넓은 CSS 자체를 수정하는 경우에도 글자 그대로 영향 범위가 넓기 때문에 어디에서 오류가 발생할지 알 수가 없다. 한 번이라도 영향 범위가 넓은 코드를 작성하게 되면 프로젝트는 계속 그 부하를 안고 가야만 한다.

결론부터 우선 이야기하면 다음 중 하나의 해결책을 적용할 수 있다.

-   범위를 줄인다.(영향 범위를 좁게 한다.)
-   영향 범위가 넓은 CSS에 포함되는 스타일링을 가능한 최소한으로 한다.

이 중 '범위를 줄인다'와 관련해 모듈 코드를 사용해서 설명해 보겠다.

### 모듈 리팩터링

```css
#main span {
    color: #555;
    font-size: 14px;
}
```

이번에는 다음 코드가 문제가 된다.

화면에 표시되는 부분은 '퍼소나란?에 이어지는 설명 부분이다.

이 절의 목적은 어디까지나 위 모듈에서 해당 부분의 색을 회색으로 변경하고 폰트 크기를 14px로 설정하는 것이다. 이를 고려하면 '#main span' 셀렉터는 분명 지나친다. 이 상태에서는 위 모듈뿐만 아니라 #main 내의 span 요소는 모두 같은 형태의 스타일을 갖게 된다.

만약 '#main 내의 span 요소는 반드시 그 스타일을 유지해야 한다'는 이유나 규칙이 있다면 이 코드 또한 한 번 더 고려해 볼 여지가 있기는 하나, 그렇지 않다면 다음과 같이 범위를 좁히는 것이 좋을 것이다.

```css
#main .bl_module.main-module span {
    color: #555;
    font-size: 14px;
}
```

하지만 필자가 보기에 이 코드 역시 범위가 조금 넓게 느껴진다. 왜냐하면 span 요소는 스타일링을 하기 위해 범용적으로 사용하는 경우가 많아서, 모듈 안에 여러 span 요소가 있더라도 각각의 형태는 전혀 다른 경우가 있기 때문이다. 따라서 다음 코드와 같이 좀더 범위를 줄이면 보다 안전한 것이다.

```css
#main .bl_modle.main-module .body > span {
    color: #555;
    font-size: 14px;
}
```

이와 같이 범위를 줄이는 경우는 가능한 가장 가까운 부모 요소까지 셀렉터에 포함시키거나, 손자 셀렉터 뿐만 아니라 자녀 셀렉터를 사용할 수 있는지 검토하는 것이 중요하다. 다만 이번 예에 한해서는 결국 '퍼소나란?' 이하의 텍스트에 스타일링을 하는 것이 목적이기 때문에, '2. HTML과 스타일링을 느슨하게 결합한다'에서 설명한 것처럼 span 요소에 'sub-text'등의 클래스를 설정하고 해당 클래스에 스타일링을 하는 것이 가장 좋은 방법이다.

앞에서 설명한 내용의 반복이지만, '영향 범위의 넓이'에 관한 포인트는 다음 두 가지이다.

-   먼저 범위를 좁힐 수 있는지 검토한다.
-   베이스 스타일 등 영향 범위가 넓은 CSS에 포함된 스타일링은 가급적 최소화 한다.

### 리팩터링 후의 코드

```css
/* 베이스, 레이아웃은 변경이 없으므로 생략합니다. */

/* 모듈
======================================== */
#main .bl_module.main-module {
    display: flex;
    align-items: center;
    font-size: 16px;
    line-height: 1.5;
}
#main .bl_module.main-module .image-wrapper {
    flex: 1 1 25%;
    margin-right: 3.33333%;
}
#main .bl_module.main-module .image-wrapper img {
    width: 100%;
    vertical-align: top;
}
#main .bl_module.main-module .body {
    flex: 1 1 68.33333%;
}
#main .bl_module.main-module .title {
    margin-bottom: 10px;
    font-size: 18px;
    font-weight: bold;
}
#main .bl_module.main-module .subtitle {
    margin-top: 10px;
    margin-bottom: 10px;
    font-size: 16px;
    border-bottom: 1px solid #555;
}

#main .bl_module.main-module .body > span {
    color: #555;
    font-size: 14px;
}
```

## 특정한 콘텍스트에 지나치게 의존하지 않는다.

다음 포인트는 '특정한 콘텍스트에 지나치게 의존하지 않는다'이다. 콘텍스트란 '위치 혹은 상황'을 의미한다. 콘텍스트에 의존하는 것이 문제가 되는 이유는 '콘텍스트가 변하면 코드가 동작하지 않게' 되기 때문이다.

### 모듈 리팩터링

다음 예제에서는 '#main .bl_module.main-module'이라는 셆렉터가 리팩터링 대상이다. 셀렉터 앞에 '#main'이 붙어 있으므로 이 셀렉터는 '#main'이라는 콘텍스트에 의존하게(#main 안에서만 움직이게) 된다.

시험삼아 모듈을 #main 밖으로 꺼내 보면 그림 2-12와 같이 스타일이 확실하게 적용되지 않는다.

모듈은 '사이트 내라면 위치에 관계없이 재사용하고 싶다'는 의미를 전제로 한다. 그러므로 '#main 안이 아닌 겨우 스타일이 적용되지 않는다'는 것은 바람직한 상황이 아니다.
