# 영단어를 결합한느 방식의 이름

한 가지 더 여러 영단어를 사용할 때의 이름에 관해 소개한다. 'subtitle'이라는 영어를 클래스 이름으로 하고자 하는 경우 다음과 같이 표기법에 관한 고민을 해보았을 것이다.

-   sub-title과 같이 각 단어를 하이픈으로 연결
-   sub_title과 같이 각 단어를 언더스코어로 연결
-   subTitle과 같이 두 번째 이후 영단어의 첫 문자를 대문자로 표기
-   SubTitle과 같이 모든 영단어의 첫 문자를 대문자로 표기

어떤 표기법이 최선인지는 문제는 제쳐 두고(라고 하기보다 결정할 수 없다.) 이들 표기법은 각각의 이름을 갖고 있다. 3장에서 소개할 다양한 설계 기법에서도 각각 다른 표기법을 사용하고 있으며 해당 내용을 설명할 때 이름을 사용한다.

## 표기법 이름

이 표기법의 이름은 CSS 설계에 국한되지 않고 프로그래밍 전반에서 공통적으로 사용하므로 꼭 기억해 두시기 바랍니다.

-   sub-title과 같이 각 단어를 하이픈으로 연결함. -> 하이픈 케이스(케밥 케이스)
-   sub_title과 같이 각 단어를 언더스코어로 연결한다. -> 스네이크 케이스
-   subTitle과 같이 두 번째 이후 영단어의 첫 문자를 대문자로 표기한다. -> 로워 캐멀 케이스
-   SubTitle과 같이 모든 영단어의 첫 문자를 대문자로 표기한다. -> 어퍼 캐멀 케이스

# 2-4 좋은 CSS 설계의 네 가지 목표

그럼 이 책의 본주제인 CSS 설계 이야기로 들어가자. 우선 추상적으로 "좋은 CSS란 무엇인가"에 대해 생각해보자.

이때 도움이 되는 지침이 "좋은 CSS 설계 네 가지 목표"인데, 이는 구글 엔지니어인 필립 왈튼의 그의 블로그에서 제창한 사고방식입니다. 이는 CSS에 조사해 보면 자주 는에 들어오는 유명한 사고방식으로 다음과 같다.

-   에측 가능하다.
-   재사용 가능하다.
-   유지 보수 가능하다.
-   확장 가능하다.

## 예측 가능하다.

"예측 가능하다"란 다시 말해 "스타일링이 기대한 대로 동작하는지", "스타일링 영향 범위를 예측할 수 있는지"를 의미한다. 새로운 스타일링을 추가하거나 기존 스타일링을 업데이트하더라도 자신이 의도하지 않은 위치에 영향을 주지 않아야 한다는 것이다.

작은 웹사이트에서는 그다지 문제가 되지 않을 수도 있다. 수십 페이지 혹은 수백 페이지로 구성된 큰 웹사이트에서 이런 사고방식은 필수이다.

## 재사용 가능하다.

예를 들어, 기존 부품을 다른 위치에서도 사용하고 싶은 경우에 코드를 일일이 다시 작성하거나 덮어쓰지 않아도 "재사용 가능한" 상태를 말한다. 이를 위해서는 스타일링이 확실하게 추상화 되어 있고 적절하게 분리되어 있어야 한다.

"추상화", "분리"라는 표현은 아직 이미지가 그려지지 않을 수도 있다. 뒤에서 소개할 [OOCSS]를 이해하면 '재사용 가능한다"고 부르는 것이 무엇인지 알 수 있을 것이다.

## 유지 보수 가능하다

새로운 모듈이나 기능을 추가, 변경 또는 그 배치를 바꿨을 때 기존 CSS를 리팩터링 필요가 없는 상태가 "유지 보수 가능한" 상태이다. 예를 들어, 모듈 A를 추가했을 때 기존에 있던 모듈 B에 영향을 주어 파괴하는 상황은 바람직하지 않다.

## 확장 가능하다

"확장 가능하다"란 CSS를 다루는 인원 수에 상관하지 않고 문제없이 관리할 수 있는 상태를 의미한다. 이를 위해서는 CSS 설계 규칙을 알기 쉽게 정의하여 학습 비용이 너무 높지 않은 상태여야 한다.

처음엔 한 사람이 개발을 시작했다 하더라도 웹사이트가 커지거나 복잡해지면 CSS를 다루는 사람이 자연히 늘어나는 것이 현대의 개발이다. 그러므로 초반 단계부터 '확장 가능한' 상태의 CSS인지 아닌지 고려해야 한다.

# 2-5 CSS 설계 실전과 여덟 가지 포인트

실제로 앞에서 설명한 "좋은 CSS 설계의 네 가지 목표"를 구현할 때 다양한 시도와 함께 코드를 작성하게 된다. 아무런 지표가 없다면 고려할 것이 너무 많아 골치가 아프다. 사실 그 방법은 다음에 설명할 여덟 가지 중 하나 혹은 그 이상에 해당한다.

이 책에서 소개할 다음 설계 기법들 역시 반드시 여덟 가지 포인트 중 어딘가에 해당하는 규칙을 갖고 있다.

-   OOCSS
-   SMACSS
-   BEM
-   PRECSS

이번 장 이후에도 '이 규칙이나 시도가 여덟 가지 포인트 중 무엇에 해당하는가?'를 짚어볼 예정이니 이 절의 내용은 수시로 확인해볼 것을 권장한다.

1. 특성에 따라 CSS를 분류한다.
2. HTML과 스타일링을 느슨하게 결합한다.
3. 영향 범위를 지나치게 넓히지 않는다.
4. 특정한 콘텍스트에 지나치게 의존하지 않는다.
5. 상세도를 지나치게 높이지 않는다.
6. 클래스 이름에서 영향 범위를 유추할 수 있다.
7. 클래스 이름에서 형태, 기능, 역할을 유추할 수 있다.
8. 확장하기 쉽다.

## 모듈

모듈이란 사이트 안에서의 재사용을 가정해 한 덩어리로 만든 부품으로 '컴포넌트(Component)라고 부른다. CSS 설계에서는 '컴포넌트', '모듈'은 모두 같은 대상을 가리키는 경우가 많다. 이 책에서는 '모듈'로 통일하자.

이 모듈은 다음과 같은 코드로 구현되어 있다고 가정한다.
리셋 CSS는 css-wipe를 사용하는 것을 전제로 한다. 미리 말씀드리면 이 코드는 이상적인 코드는 아니다.(오히려 형편없어서 보고 있으면 기분이 나빠지는 코드이다.) CSS 설계의 여덟 가지 포인트를 소개하고 설명하면서 이 코드를 PRECSS에 맞춰 리팩터링해 간다. PRECSS에 관한 상세한 내용은 3장에서 알아볼 것이다.

지금 단계에선 중요치 않으므로 계속 읽어보자.

## 특성에 따라 CSS를 분류한다.

첫 번째는 CSS 분류에 관한 내용으로 다음과 같이 CSS역할이나 특성에 따라 그룹을 나누는 것이다.

-   예를 들어, 리셋 CSS나 링크 텍스트는 빨간색으로 한다 = a { color : red}'와 같이 사이트 전체에 기반이 되는 베이스 스타일을 '베이스 그룹'으로 만든다.
-   헤어나 푸터 그리고 콘텐츠 영역을 형성하는 스타일링을 '레이아웃 그룹'으로 만든다.

각 설계 기법은 다음 3장에서 자세하게 설명한다. 이 기법은 SMACSS, PRECSS에서 채용하고 있다. 또한 이 분류의 모듈 이름에 추가적으로 접두사를 붙이면 어떤 분류에 해당하는지 눈으로 확인할 수 있다. 예를 들어, 레이아웃과 관련한 코드에 대해 SMACSS에서는 '-l', PRECSS에선 'ly*'라는 접두사를 붙인다. PRECSS에서는 모듈 분류 시 'el*', 'bl\_'과 같은 접두사를 사용한다.

```css
#main div.module.main-module {
    /*좌우 가운데 정렬을 위한 지정*/
    max-width: 1200px;
    padding-right: 15px;
    padding-left: 15px;
    margin-right: auto;
    margin-left: auto;
    /* 모듈에 대한 지정 */
    display: flex;
    align-items: center;
    font-family: sans-serif
    font-size: 16px;
    line-height: 1.5;
}
```

베이스 폰트를 지정한 CSS이다. 베이스 폰트는 기본적으로 이 모듈에만 국한되지 않으며 사이트 전체에 공통으로 적용된다. 새로운 모듈을 만들 때마다 폰트를 지정하는 것은 매우 번거로운 작업이다. 여기에서는 고딕체(sans-serif)를 지정했지만, '사이트 전체의 글씨체를 명조체로 하고 싶다'와 같은 경우에도 모듈 지정한다면 수정할 위치가 많아진다. 따라서 폰트 지정 등은 모듈이 아니라 body 요소에 적용하도록 한다.

```css
body {
    font-family: sans-serif;
}
```

이외에도 '사이트 내 공통으로 적용할 것', '사이트 베이스로 하면 좋을 만한 것'은 베이스 그룹에 해당한다. 예를 들어, 반응형 디자인(Responsive Design)을 구성하는 요소의 하나인 프루이드 이미지(Fluid Image) 코드 등도 베이스 그룹이라 할 수 있습니다. 즉, 요소형 셀렉터를 사용해서 스타일링 하는 것들이다.

```css
img {
    max-width: 100%;
    height: auto;
}
```

### 레이아웃 그룹 정의

```css
main div.module.main-module {
    /* 좌우 가운데 정렬을 위한 설정, 이 코드를 주목 */
    max-width: 1200px;
    padding-right: 15px;
    padding-left: 15px;
    margin-right: auto;
    margin-left: auto;
    /* 모듈을 위한 지정 */
    display: flex;
    align-items: sans-serif;
    font-family: 16px;
    font-size: 16px;
    line-height: 1.5;
}
```

이 코드들을 그림 2-8과 같이 콘텐츠 영역에 대해 모듈을 최대 폭인 1200px에서 좌우 가운데 정렬로 배치하기 위한 코드이다.

이후 다른 모듈을 추가해도 모두 좌우 가운데 정렬로 1200px의 콘텐츠 내에 들어가면 좋을 것이다. 그때마다 모듈별로 max-width와 padding-right, padding-left, margin-right, margin-left를 설정하는 것은 많은 수고가 들뿐더러 번거롭고 불필요한 작업이기도 하다. 따라서 이들 속성은 레이아웃 그룹, 즉 "주로 위치 조정을 담당하는 코드"로 분리한다.

이를 위해 레이아웃과 관련한 것을 담당하기 위한 클래스로 'ly*cont'를 새롭게 만들고, 모듈이 아닌 한 단계 상위의 콘텐츠 영역 전체를 활용하는 article 요소에 클래스를 추가한다. 'ly*'는 레이아웃 그룹에 있다는 것을 의미하는 접두사다.

```html
<article id="main" class="ly_cont">
    <!-- ly_cont를 추가 -->
    <div class="module main-module">(생략)</div>
</article>
```

```css
.ly_cont {
    max-width: 1200px;
    padding-right: 15px;
    padding-left: 15px;
    margin-right: auto;
    margin-left: auto;
}
#main div.module.main-module {
    display: flex;
    align-items: center;
    font-size: 16px;
    line-height: 1.5;
}
```

이후에는 콘텐츠 영역을 정의하기 위한 max-width와 padding-right, padding-left, margin-right, margin-left를 매번 설정할 필요가 없으며, 콘텐츠 영역이 1200px에서 변경된 경우에도 ly*cont만 수정하면 된다. 또한 'ly*' 접두사를 사용해서 HTML을 보기만 해도 '이 클래스가 레이아웃을 담당하고 있음'을 한 눈에 알 수 있다.

### 모듈 그룹 정의

모듈 그룹은 사이트 전체에서 재사용하는 것을 가정하고 있으므로 한 눈에 쉽게 들어오도록 모듈 이름 'bl\_'이라는 접두사를 붙인다.

```html
<div class="bl_module main-module">
    <!-- bl_이라는 접두사를 붙인다. -->
</div>
```

이를 통해 "bl\_이 붙어 있는 것은 모듈 그룹이며 어떠한 페이지에서도 재사용할 수 있다"는 것을 확인할 수 있다.

### 리팩터링 후의 코드

코드를 분류한 것 만으로도 코드가 보다 깔끔해졌다. 뿐만 아니라 다음과 같이 적절하게 분류하면 이후에 발생할 요구 사항이나 수정에도 쉽게 대응할 수 있다.

-   베이스 그룹: 사이트 전체에 적용해야 할 스타일은 베이스 그룹
-   레이아웃 그룹: 레이아웃과 관련 있는 스타일은 레이아웃 그룹
-   모듈 그룹: 사이트 내 페이지들에서 재사용할 수 있는 것은 모듈 그룹

### 모듈에 대한 레이아웃 지정

지금까지 진행한 것처럼 기본적으로 모듈 자체에는 레이아웃과 관련된 지정은 하지 않는 것이 좋다. '레이아웃과 관련된 지정'이란 구체적으로 다음 항목 등을 가리킨다.

[레이아웃과_관련된_지정]

-   position
-   z-index
-   top / right / bottom / left
-   float
-   width
-   margin

모듈 자체에 이 값들을 지적접 지정하지 않음으로써 모듈들은 블록 레벨 요소의 특성에 따라 부모 요소의 가로 폭 100%를 채우게 되고, 여러 모듈을 세로로 배치하는 경우에는 상하 여백없이 붙은 상태가 된다. 이 상태에서는 어떤 위치에서 모듈을 사용하더라도 모양이 깨지지 않으며, 레이아웃과 관련한 스타일을 무시하기 위해 CSS 코드를 작성하지 않다도 되므로 재 사용성이 매우 높다.

하지만 현실적으로 모듈 사이 위아래 여백을 일일이 설정하는 것은 번거로울 수도 있다. 그래서 margin-top / margin-bottom 정도는 모듈 자체에 포함시켜도 좋을 것이다. -> 7장 참고.

모듈에 대한 레이아웃과 관련한 지정에 대해 다소 어려운 이야기를 해보면 '모듈은 해당 모듈 자체에 관한 처리 및 처리 요소의 스타일링에만 관심을 가져야 하며, '자신이 어디에 어떤 크기로 배치되어야 하는가?'에 관해서는 레이아웃 그룹 혹은 모듈을 사용하는 콘텍스트에 맡긴다'고 할 수 있다.

조금 어려운 내용이기는 하나 지금은 전부 이해하지 않아도 괜찮다. 다만 '모듈 자체에는 레이아웃과 관련된 지정을 하지 않는다'는 내용이 책 중간중간 등장하므로 그 때는 이번 장의 설명을 다시 읽어 보면서 조금씩 이해를 높여 가길 바란다.

[컨텍스트]
앞에서 언급한 '장소, 상황'이라는 단어는 보통 '콘텍스트(직역하면 '문맥')'라고 불린다. 이 '콘텍스트'라는 용어는 CSS 설계뿐만 아니라 다른 프로그래밍 용어에서도 자주 사용하므로 기억해두자.

## HTML과 스타일링을 느슨하게 결합한다.

다음 포인트는 'HTML과 스타일링을 느슨하게 결합한다.'이다. 느슨한 결합이라는 용어가 조금 낯설지도 모르겠다. 이는 의미상 'HTML과의 결합이 강하지 않다' 또는 'HTML에 의존하지 않는다' 등으로 표현할 수 있다. 반대로 HTML에 강하게 결합한, 다시 말해 의존하는 상태를 'HTML과 밀접하게 결합해 있다'고 말한다.

-   '밀접한 결합/느슨한 결합'이라는 말은 CSS 설계에만 국한한 것이 아니라 프로그래밍 전방에서 자주 사용하는 표현

HTML과 스타일링을 느슨하게 결합하는 것이 좋은 이유?

<그림\_2-9> h2 요소를 사용한 위치에 주목하자.
모듈은 다양한 페이지에서의 재사용을 전제로 하고 있다. 하지만 제목 요소는 문서 구조에 영향을 미치며, 사용되는 페이지, 위치 혹은 상황에 따라 h3 혹은 h4로 설정해야 할 때가 있다. 이런 변경에도 대응할 수 있는 간단한 방법으로 다음 코드와 같이 그룹 셀렉터를 사용할 수 있다.

````css
#main div.bl_module.main-module h2,
#main div.bl_module.main-module h3,
#main div.bl_module.main-module h4 {
    margin-bottom: 10px;
    font-size: 18px,
    font-weight: bold;
}

그러나 이 코드를 사용하면 h3 스타일이 보통 굵기의 텍스트로 표시될 것이라는 예상과 달리 그림 2-10과 같이 '퍼소나란?' 위치가 굵게 표시된다.

이는 다음 코드와 같이 h3 요소에 대해 스타일링이 중복되기 때문이다.

```css
#main div.blmodule.main-module h2,
#main div.blmodule.main-module h3,
#main div.blmodule.main-module h4 {
    margin-bottom: 10px;
    font-size 18px;
    font-weight: bold; /* 이 스타일링이 '퍼소나란? 에 적용되어 버림 */
}
#main div.bl_module.main-module h3 {
    margin-top: 10px;
    margin-bottom: 10px;
    font-size: 16px;
    border-bottom: 1px solid #555;
}
````

'퍼소나란?'은 h3, h4 양쪽 모두가 될 수 있기 때문에 같은 방법으로는 셀렉터를 h4만으로 할 수동 없다. 요소형 셀렉터를 사용하는 한, 이런 복잡하고 번거로운 문제는 항상 따라다닌다.

이 문제는 간단하게 해결할 수 있다. '요소형 셀렉터를 사용하지 않는다.' 다시 말해 'HTML과 스타일링을 약하게 연결(=느슨하게 결합)'하면 된다. 예를 들면, '사용자를 고려한~'에는 'title'이라는 클래스 이름, '퍼소나란?'에는 'sub-title'이라는 클래스 이름의 클래스 셀렉터를 사용하면 이 문제를 간단히 회피할 수 있다.

```html
<article id="main" class="ly_cont">
    <div class="bl_module main module">
        <h2 class="title">사용자를 고려한 설계로 만족스러운 체험을</h2>
        <h3 class="sub-title">퍼소나란?</h3>
    </div>
</article>
```

```css
#main div.bl_module.main-module .title {
    margin-bottom: 10px;
    font-size: 18px;
    font-weight: bold;
}
#main div.bl_module.main-module .sub-title {
    margin-top: 10px;
    margin-bottom: 10px;
    font-size: 16px;
    border-bottom: 1px solid #555;
}
```

이제 각 제목은 어떤 레벨이든 스타일링이 섞이지 않는다. 제목 요소 뿐만 아니라 다른 요소들에 대해서도 HTML 요소 이름은 가급적 셀렉터로 사용하지 않는 것이 최선의 선택이다. 예를 들어, 지금까지 div 요소였던 것이 무언가의 이유로 p 요소로 바뀌면 div 요소에 설정했던 스타일이 적용되지 않기 떄문이다. 따라서 각 셀렉터에'#main div.bl_module.main-module'이라고 되어 있는 코드에서 'div'를 잘라 낸다.

이는 '5. 상세도를 지나치게 높이지 않는다'와도 연결된다.

### 리팩터링 후의 코드

지금까지 설명한 내용을 포함해 모듈 내 요소에 대한 스타일링을 전체적으로 클래스 셀렉터를 사용한 방법으로 변경한 코드를 실었따. 현실적으로 모든 요소에 클래스를 정하는 것은 상당한 노력이 드는 작업이기도 하다. 예를 들어, 다음 코드의 '#main .bl_module.main-module .image-wrapper img{}` 셀렉터와 같이 어느 정도 범위가 교차하는 요소에 관해서는 HTML 요소 이름을 그대로 사용해도 큰 지장은 없다. 단, div 요소나 p 요소, span 요소는 모듈 내에서 자주 사용하므로, 이들에 대해서는 확실히 클래스 이름을 설정해 두면, 나중에 모듈을 개선할 필요가 발생했을 때 유용하게 사용할 수 있다.
('#main span'은 '3. 영향을 지나치게 넓히지 않는다'에서 설명하기 위해 현재 상태를 유지했다.)

```html
<article id="main" class="ly_cont">
    <div class="bl_mdoule main-module">
        <figure class="image-wrapper">
            <img src="#" alt="사진: 손에 든 스마트폰" />
        </figure>
        <div class="body">
            <h2 class="title">사용자를 고려한 설계로 만족스러운 체험을</h2>
            <p>
                웹사이트 설계는 제공하는 서비스나 퍼소나에 따라 달라집니다.
                서비스와 퍼소나에 맞춘 설계를 통해 방문자에게 스트레스를 주지
                않는 보다 나은 체험을 만들어 만족감을 높입니다. <br />
                우리는 고객의 사이트에 맞는 사용성을 고려하기 때문에 세심한
                분석과 의견 청취를 실시함으로써, 만족을 체험할 수 있는
                크리에이티브 및 테크놀로지를 설계하고 구현함으로써 지금까지는
                없던 기대를 뛰어넘는 사용자 체험을 제공합니다.
            </p>
            <h3 class="sub-title">퍼소나란?</h3>
            <span>
                자사 상품, 서비스의 이상적/ 상징적인 고객 이미지를 말합니다.
                접근할 대상을 명확히 함으로써 효율적인 마케팅을 수행할 수
                있습니다.
            </span>
        </div>
    </div>
</article>
```

```css
/* 베이스, 레이아웃은 변경이 없으므로 생략합니다. */

/* 모듈
======================================== */
#main span {
    color: #555;
    font-size: 14px;
}
#main .bl_module.main-module {
    display: flex;
    align-items: center;
    font-size: 16px;
    line-height: 1.5;
}
#main .bl_module.main-module .image-wrapper {
    flex: 1 1 25%;
    margin-right: 3.33333%;
}
#main .bl_module.main-module .image-wrapper img {
    width: 100%;
    vertical-align: top;
}
#main .bl_module.main-module .body {
    flex: 1 1 68.33333%;
}
#main .bl_module.main-module .title {
    margin-bottom: 10px;
    font-size: 18px;
    font-weight: bold;
}
#main .bl_module.main-module .subtitle {
    margin-top: 10px;
    margin-bottom: 10px;
    font-size: 16px;
    border-bottom: 1px solid #555;
}
```

HTML과 스타일링을 느슨하게 결합하는 것은 "좋은 CSS 설계의 네 가지 목표"에서 소개한 "재사용 가능하다", "유지 보수 가능하다"와도 이어진다.

### HTML과 스타일링을 밀접하게 결합한 패턴

지금까지의 모듈과는 관계가 없지만, HTML과 스타일링을 밀접하게(강하게) 결합한 패턴을 하나 확인해보자.

```css
a[href="google.co.kr"] {
    color: red;
}
```

이 스타일링은 "링크 대상이 https://google.co.kr이라면 문자 색상을 빨간생그로 한다"는 것을 의미한다. 하지만 뒤엇 'http://www.naver.com의 경우에도 빨갛게 하고 싶다'는 추가 요청이 있다면 어떻게 해야 할까?

단순하게 생각하면 다음과 같이 그룹 셀렉터를 사용해 대응할 수 있다.

```css
a[href="google.co.kr"],
a[href="naver.com"] {
    color: red;
}
```

이런 추가 요청이 있을 떄마다 CSS에 해당 내용을 추가하는 것은 번거롭다. 속성 셀렉터를 사용하거나 또는 '특정한 문자열을 가진 경우(링크 대상이 구글 혹인 네이버인 경우)'에는 그룹 셀럭터의 코드를 늘리지 않는 한 다른 문자열 색상을 빨간색으로 하고 싶은 패턴에 대응할 수 없다.

그런고로 속성 셀렉터의 특정값을 사용한 스타일링 또한 기본적으로 피해야 한다.

## 영향 범위를 지나치게 넓히지 않는다.

다음 포인트는 '영향 범위를 지나치게 넓히지 않는다'이다. 여기에서는 [지나치게]라는 점이 핵심이며, 확실하게 계산한 결과 영향 범위가 넓은 CSS를 사용한 것이라면 그다지 큰 문제는 없다. 베이스 그룹의 코드 등이 이에 해당한다.

그러나 영향 범위가 넓은 CSS에 불필요한 스타일링 등을 포함하면 상황이 매우 힘들어진다. 새로운 모듈을 만들 때 불필요한 스타일링을 비활성화하는 코드를 작성해야만 하고, 영향 범위가 넓은 CSS 자체를 수정하는 경우에도 글자 그대로 영향 범위가 넓기 때문에 어디에서 오류가 발생할지 알 수가 없다. 한 번이라도 영향 범위가 넓은 코드를 작성하게 되면 프로젝트는 계속 그 부하를 안고 가야만 한다.

결론부터 우선 이야기하면 다음 중 하나의 해결책을 적용할 수 있다.

-   범위를 줄인다.(영향 범위를 좁게 한다.)
-   영향 범위가 넓은 CSS에 포함되는 스타일링을 가능한 최소한으로 한다.

이 중 '범위를 줄인다'와 관련해 모듈 코드를 사용해서 설명해 보겠다.

### 모듈 리팩터링

```css
#main span {
    color: #555;
    font-size: 14px;
}
```

이번에는 다음 코드가 문제가 된다.

화면에 표시되는 부분은 '퍼소나란?에 이어지는 설명 부분이다.

이 절의 목적은 어디까지나 위 모듈에서 해당 부분의 색을 회색으로 변경하고 폰트 크기를 14px로 설정하는 것이다. 이를 고려하면 '#main span' 셀렉터는 분명 지나친다. 이 상태에서는 위 모듈뿐만 아니라 #main 내의 span 요소는 모두 같은 형태의 스타일을 갖게 된다.

만약 '#main 내의 span 요소는 반드시 그 스타일을 유지해야 한다'는 이유나 규칙이 있다면 이 코드 또한 한 번 더 고려해 볼 여지가 있기는 하나, 그렇지 않다면 다음과 같이 범위를 좁히는 것이 좋을 것이다.

```css
#main .bl_module.main-module span {
    color: #555;
    font-size: 14px;
}
```

하지만 필자가 보기에 이 코드 역시 범위가 조금 넓게 느껴진다. 왜냐하면 span 요소는 스타일링을 하기 위해 범용적으로 사용하는 경우가 많아서, 모듈 안에 여러 span 요소가 있더라도 각각의 형태는 전혀 다른 경우가 있기 때문이다. 따라서 다음 코드와 같이 좀더 범위를 줄이면 보다 안전한 것이다.

```css
#main .bl_modle.main-module .body > span {
    color: #555;
    font-size: 14px;
}
```

이와 같이 범위를 줄이는 경우는 가능한 가장 가까운 부모 요소까지 셀렉터에 포함시키거나, 손자 셀렉터 뿐만 아니라 자녀 셀렉터를 사용할 수 있는지 검토하는 것이 중요하다. 다만 이번 예에 한해서는 결국 '퍼소나란?' 이하의 텍스트에 스타일링을 하는 것이 목적이기 때문에, '2. HTML과 스타일링을 느슨하게 결합한다'에서 설명한 것처럼 span 요소에 'sub-text'등의 클래스를 설정하고 해당 클래스에 스타일링을 하는 것이 가장 좋은 방법이다.

앞에서 설명한 내용의 반복이지만, '영향 범위의 넓이'에 관한 포인트는 다음 두 가지이다.

-   먼저 범위를 좁힐 수 있는지 검토한다.
-   베이스 스타일 등 영향 범위가 넓은 CSS에 포함된 스타일링은 가급적 최소화 한다.

### 리팩터링 후의 코드

```css
/* 베이스, 레이아웃은 변경이 없으므로 생략합니다. */

/* 모듈
======================================== */
#main .bl_module.main-module {
    display: flex;
    align-items: center;
    font-size: 16px;
    line-height: 1.5;
}
#main .bl_module.main-module .image-wrapper {
    flex: 1 1 25%;
    margin-right: 3.33333%;
}
#main .bl_module.main-module .image-wrapper img {
    width: 100%;
    vertical-align: top;
}
#main .bl_module.main-module .body {
    flex: 1 1 68.33333%;
}
#main .bl_module.main-module .title {
    margin-bottom: 10px;
    font-size: 18px;
    font-weight: bold;
}
#main .bl_module.main-module .subtitle {
    margin-top: 10px;
    margin-bottom: 10px;
    font-size: 16px;
    border-bottom: 1px solid #555;
}

#main .bl_module.main-module .body > span {
    color: #555;
    font-size: 14px;
}
```

## 특정한 콘텍스트에 지나치게 의존하지 않는다.

다음 포인트는 '특정한 콘텍스트에 지나치게 의존하지 않는다'이다. 콘텍스트란 '위치 혹은 상황'을 의미한다. 콘텍스트에 의존하는 것이 문제가 되는 이유는 '콘텍스트가 변하면 코드가 동작하지 않게' 되기 때문이다.

### 모듈 리팩터링

다음 예제에서는 '#main .bl_module.main-module'이라는 셆렉터가 리팩터링 대상이다. 셀렉터 앞에 '#main'이 붙어 있으므로 이 셀렉터는 '#main'이라는 콘텍스트에 의존하게(#main 안에서만 움직이게) 된다.

시험삼아 모듈을 #main 밖으로 꺼내 보면 그림 2-12와 같이 스타일이 확실하게 적용되지 않는다.

모듈은 '사이트 내라면 위치에 관계없이 재사용하고 싶다'는 의미를 전제로 한다. 그러므로 '#main 안이 아닌 겨우 스타일이 적용되지 않는다'는 것은 바람직한 상황이 아니다.

따라서 다음 코드와 같이 #main을 셀렉터에서 빼내서 #main에 관계없이 어디서나 사용될 수 있도록 합시다.

```css
.bl_module.main-module {
    display: flex;
    align-items: center;
    font-size: 16px;
    line-height: 1.5;
}
```

덧붙어 콘텐츠 영역의 가로 폭(1200px) 지정과 좌우 가운데 정렬이 적용되어 있는 것은 레이아웃 코드를 확실히 ly_cont 클래스로 분리한 덕이다.

### 리팩터링 후의 코드

#main이 셀렉터에서 빠짐으로써 코드가 상당히 깔끔해졌다.

```css
/* 베이스, 레이아웃은 변경이 없으므로 생략합니다. */

/* 모듈
======================================== */
.bl_module.main-module {
    display: flex;
    align-items: center;
    font-size: 16px;
    line-height: 1.5;
}
.bl_module.main-module .image-wrapper {
    flex: 1 1 25%;
    margin-right: 3.33333%;
}
.bl_module.main-module .image-wrapper img {
    width: 100%;
    vertical-align: top;
}
.bl_module.main-module .body {
    flex: 1 1 68.33333%;
}
.bl_module.main-module .title {
    margin-bottom: 10px;
    font-size: 18px;
    font-weight: bold;
}
.bl_module.main-module .subtitle {
    margin-top: 10px;
    margin-bottom: 10px;
    font-size: 16px;
    border-bottom: 1px solid #555;
}

.bl_module.main-module .body > span {
    color: #555;
    font-size: 14px;
}
```

## 상세도를 지나치게 높이지 않는다.

이어지는 포인트는 '상세도를 지나치게 높이지 않는다'이다. 상세도가 높은 CSS는 기본적으로 다음 이유로 그다지 좋지 않다.

-   셀렉터를 예측하기 어렵다.
-   다른 요소(부모 요소 등)에 대한 의존도가 높아진다.
-   덮어쓰기가 어렵다.
-   유지 보수에 들어가는 수고가 증가한다.

'기존의 CSS 상세도가 너무 높아서 덮어쓰기 어려워 어쩔 수 없이 !important를 사용한다'와 같은 경험을 해본 적이 있지 않은가? !important를 사용할수록 덮어쓰기가 어려워지므로 처음부터 가급적 상세도를 억제하는 것이 CSS를 오랫동안 깔끔하게 운용하는 비결이다.

실제 상세도를 낮추기 위한 기본 팁을 소개하자면 '셀렉터를 사용할 때는 클래스 셀렉터를 사용한다.'는 것이다. ID 셀렉터는 그 자체로 상세도가 높으며 HTML 측의 한 페이지 안에서 동일한 값은 한 번만 사용해야 한다는 제약이 있기 떄문에 ID를 스타일링 목적으로 상요해서 얻을 수 있는 장점은 그다지 많지 않다.

### 모듈 리팩터링

지금까지의 모듈 코드에는 'main-module'이라는 클래스가 존재했고, CSS 셀렉터도 다음 코드처럼 이 main-module에 포함된 형태였다.

```css
.bl_module.main-module {
    ...;
}
```

하지만 클래스가 여럿 붙어있다고 해서 일부러 셀렉터에까지 여러 클래스를 붙일 필요는 없다.

이 샘플의 main-module이라는 클래스 이름은 '#main 안에 있는 모듈' 정도의 의미를 갖고 있는 것으로, main-module 그 자체에 대해 특별한 스타일링을 수행하지는 않는다. 그리고 '4. 특정한 콘텍스트에 지나치게 의존하지 않는다'에서도 설명했듯, 기본적으로 모듈이 특정한 콘텍스트에 의존하는 것은 상식에 맞지 않으므로 HTML/CSS에서 main-module을 제거한다. 결과적으로 다음과 같은 코드가 된다.

```css
.bl_module {
    ...;
}
```

### 리팩터링 후의 코드

여기에서는 HTML도 변경하긴 했지만, 'main-module'을 삭제한 정도의 간단한 변경이므로 CSS만 살펴보자. 코드가 점점 아름다워져 간다.

```css
/* 베이스, 레이아웃은 변경이 없으므로 생략합니다. */

/* 모듈
======================================== */
.bl_module {
    display: flex;
    align-items: center;
    font-size: 16px;
    line-height: 1.5;
}
.bl_module .image-wrapper {
    flex: 1 1 25%;
    margin-right: 3.33333%;
}
.bl_module .image-wrapper img {
    width: 100%;
    vertical-align: top;
}
.bl_module .body {
    flex: 1 1 68.33333%;
}
.bl_module .title {
    margin-bottom: 10px;
    font-size: 18px;
    font-weight: bold;
}
.bl_module .subtitle {
    margin-top: 10px;
    margin-bottom: 10px;
    font-size: 16px;
    border-bottom: 1px solid #555;
}

.bl_module .body > span {
    color: #555;
    font-size: 14px;
}
```

## 클래스 이름에서 영향 범위를 유추할 수 있다.

이번 포인트는 '클래스 이름에서 영향 범위를 유추할 수 있다'이다. 웹사이트는 그 규모가 커질수록 모듈이나 다른 클래스도 늘어나기 때문에 '이 클래스를 수정하면 어느 정도의 범위에 영향을 미치는가'를 클래스 이름에서 판단할 수 있는 점이 매우 중요하다.

'3. 영향 범위를 지나치게 넓히지 않는다'에서도 다루었지만 영향 범위가 넓은 코드 또한 때로는 필요하기 때문에 '영향 범위가 넓은 것'이 문제가 아니라, '영향 범위가 좁은지 넓은지 클래스 이름에서 확실하게 알 수 있도록 한다'는 점이 이 절에서 전달하고자 하는 바이다. 이 포인트를 확인하는 팁은 'HTML'만 봤을 때의 영향 범위가 CSS에서의 스타일링과 일치하는가'이다.

### 모듈 리팩터링

현시점에서의 HTML 코드를 확인하자.

```html
<article id="main" class="ly_cont">
    <div class="bl_mdoule main-module">
        <figure class="image-wrapper">
            ⭐️
            <img src="#" alt="사진: 손에 든 스마트폰" />
        </figure>
        <div class="body">
            ⭐️
            <h2 class="title">⭐️ 사용자를 고려한 설계로 만족스러운 체험을</h2>
            <p>
                웹사이트 설계는 제공하는 서비스나 퍼소나에 따라 달라집니다.
                서비스와 퍼소나에 맞춘 설계를 통해 방문자에게 스트레스를 주지
                않는 보다 나은 체험을 만들어 만족감을 높입니다. <br />
                우리는 고객의 사이트에 맞는 사용성을 고려하기 때문에 세심한
                분석과 의견 청취를 실시함으로써, 만족을 체험할 수 있는
                크리에이티브 및 테크놀로지를 설계하고 구현함으로써 지금까지는
                없던 기대를 뛰어넘는 사용자 체험을 제공합니다.
            </p>
            <h3 class="sub-title">퍼소나란?</h3>
            ⭐️
            <span>
                자사 상품, 서비스의 이상적/ 상징적인 고객 이미지를 말합니다.
                접근할 대상을 명확히 함으로써 효율적인 마케팅을 수행할 수
                있습니다.
            </span>
        </div>
    </div>
</article>
```

필자가 문제라고 생각한 코드에 ⭐️을 붙였다. 이는 모두 모듈의 자녀 요소에 붙인 클래스 이름이다.

-   image-wrapper
-   body
-   title
-   sub-title

예를 들어, 'title'이라는 클래스의 경우, 클래스 이름만 보면 이 모듈 밖에서도 제목으로 사용할 수 있을 것 같은 느낌이 든다. 하지만 다음 코드와 같이 모듈 밖에서 title 클래스를 사용하면 예상과 다르게 CSS가 적용되지 않는다.

```html
<article id="main" class="ly_cont">
    <div class="bl_module">(생략)</div>
    <!-- 섹션 제목을 만들기 위해 다음 코드를 추가해도 모듈 밖이어서 title CSS가 적용되지 않음 -->
    <h2 class="title">디지털 마케팅 지원</h2>
</article>
```

CSS를 확인해 보면 이는 당연한 결과이다.

```css
.bl_module .title {
    margin-button: 10px;
    font-size: 18px;
    font-weight: bold;
}
```

프로젝트 안에 이런 코드가 산재해 있다면 혼란이 벌어지는 것도 당연하다. '시험 삼아 클래스를 다른 위치에서 사용해 봤지만 스타일이 적용되지 않는' 상황이 발생할 때마다 CSS 셀렉터가 어떠헥 되어 있는지 일일이 확인하는 것은 매우 번거로운 일이다.

이런 문제에 대한 기본적인 해결책, 다시 말해 클래스 이름에서 영향 범위를 유추할 수 있도록 하려면 어떻게 해야 할까?
=> '모듈의 자녀 요소에는 모듈의 루트 요소의 클래스 이름을 상속 시키는 방법을 사용하는 것을 추천한다. 루트 요소란 모듈의 기점이 되는(최상위 부모가 되는) 요소를 의미하며, 이번 예시에서는 <div class="bl_module"></div>이 루트 요소에 해당한다.

bl_module 안에서만 사용될 title은 'bl_module_title'과 같은 이름을 붙이는 것이다.

요약하자면 '자녀 요소의 클래스 이름의 머리에는 모듈 이름을 붙인다'는 것이다. 이렇게 하면 제목 모듈 부분의 코드는 다음과 같이 되므로 '이 제목의 코드를 모듈 밖으로 꺼내자'라는 생각은 하지 않게 된다.

```html
<div class="bl_module">
    (생략)
    <h2 class="bl_module_title">사용자를 고려한 만족스러운 체험을</h2>
    (생략)
</div>
```

범용적으로 사용하고 싶은 클래스를 시각화할 것. 모듈 자녀요소에 모듈 루트 요소의 클래스 이름을 상속시킴으로써.

'모듈 자녀 요소에 모듈 루트 요소의 클래스 이름을 상속시키는' 방법에 따라 모듈에 관계없이 범용적으로 사용하고 싶은 클래스를 눈으로 확인하기 쉬워진다. 예를 들어, '퍼소나란?'에 적용되어 있는 스타일링을 다른 위치에서도 사용할 수 있도록 한다고 가정해보자. 그 경우에 'sub-title' 클래스에 모듈명을 붙이지 않고 그대로 둔다. 그러면 다른 자녀 요소가 클래스 이름에 'bl_module'을 가지고 있는 것에 비해 sub-title은 bl_module을 가지고 있지 않으므로, '이것은 bl_module 밖에서도 사용할 수 있을 것 같다.'고 예측할 수 있다. 물론 CSS 셀렉터 역시 그에 맞게 바꿔 쓴다.

```html
<div class="bl_module">
    (생략)
    <h2 class="bl_module_title">사용자를 고려한 만족스러운 체험을</h2>
    (생략)
    <h3 class="sub-title">퍼소나란?</h3>
</div>
```

```css
.sub-title {
    margin-top: 10px;
    margin-bottom: 10px;
    font-size: 16px;
    border-bottom: 1px solid #555;
}
```

### 리팩터링 후의 코드

위 내용을 적용해 리팩터링한 코드 전체를 실었다. 또한 'image-wrapper', 'sub-title'과 같이 하이픈 케이스를 사용한 부분은 PRECSS 표기 규칙에 따라 'imageWrapper', 'subTitle'과 같이 로워 카멜 케이스로 변경했다.

```html
<article id="main" class="ly_cont">
    <div class="bl_mdoule">
        <figure class="bl_module_image-wrapper">
            ⭐️
            <img src="#" alt="사진: 손에 든 스마트폰" />
        </figure>
        <div class="bl_module_body">
            ⭐️
            <h2 class="bl_module_title">
                ⭐️ 사용자를 고려한 설계로 만족스러운 체험을
            </h2>
            <p>
                웹사이트 설계는 제공하는 서비스나 퍼소나에 따라 달라집니다.
                서비스와 퍼소나에 맞춘 설계를 통해 방문자에게 스트레스를 주지
                않는 보다 나은 체험을 만들어 만족감을 높입니다. <br />
                우리는 고객의 사이트에 맞는 사용성을 고려하기 때문에 세심한
                분석과 의견 청취를 실시함으로써, 만족을 체험할 수 있는
                크리에이티브 및 테크놀로지를 설계하고 구현함으로써 지금까지는
                없던 기대를 뛰어넘는 사용자 체험을 제공합니다.
            </p>
            <h3 class="sub-title">퍼소나란?</h3>
            ⭐️
            <span>
                자사 상품, 서비스의 이상적/ 상징적인 고객 이미지를 말합니다.
                접근할 대상을 명확히 함으로써 효율적인 마케팅을 수행할 수
                있습니다.
            </span>
        </div>
    </div>
</article>
```

```css
.bl_module {
    display: flex;
    align-items: center;
    font-size: 16px;
    line-height: 1.5;
}
.bl_module_image-wrapper {
    flex: 1 1 25%;
    margin-right: 3.33333%;
}
.bl_module .bl_module_image-wrapper img {
    width: 100%;
    vertical-align: top;
}
.bl_module .bl_module_body {
    flex: 1 1 68.33333%;
}
.bl_module .bl_module_title {
    margin-bottom: 10px;
    font-size: 18px;
    font-weight: bold;
}
.bl_module .bl_module_body > span {
    color: #555;
    font-size: 14px;
}
.bl_module .subTitle {
    margin-top: 10px;
    margin-bottom: 10px;
    font-size: 16px;
    border-bottom: 1px solid #555;
}
```

여기에서 리팩터링을 한 단계 더 수행한다. 앞서 설명한 '5. 상세도를 지나치게 높이지 않는다'에 따라 상세도를 낮출 수 있는 여지가 있기 때문이다. 리팩터링 전의 셀렉터는 'bl_module .title'였다. 이 상태에서 상세도를 낮추면 '.title'이 되지만, 이 상태로는 모듈 안팎에 관계없이 title 클래스를 사용할 수 있게 되므로 의미가 달라진다.

하지만 현재의 셀렉터는 '.bl_module .bl_module_title'이며 제목 클래스 이름에 모듈 이름을 포함하고 있으므로, 상세도를 낮춰 '.bl_module_title'로 하더라도 계속해서 '모듈 안에서 사용하는 타이틀'임을 확실하게 전달할 수 있다. 상세도를 낮춰 리팩터링한 코드는 다음과 같다.

```css
.bl_module {
    display: flex;
    align-items: center;
    font-size: 16px;
    line-height: 1.5;
}
.bl_module_image-wrapper {
    flex: 1 1 25%;
    margin-right: 3.33333%;
}
.bl_module_image-wrapper img {
    width: 100%;
    vertical-align: top;
}
.bl_module_body {
    flex: 1 1 68.33333%;
}
.bl_module_title {
    margin-bottom: 10px;
    font-size: 18px;
    font-weight: bold;
}
.bl_module_body > span {
    color: #555;
    font-size: 14px;
}
.subTitle {
    margin-top: 10px;
    margin-bottom: 10px;
    font-size: 16px;
    border-bottom: 1px solid #555;
}
```

코드 형태가 상당히 좋아졌다.

## 클래스 이름에서 형태, 기능, 역할을 유추할 수 있다.

이전 절에서 설명한 '6. 클래스 이름에서 영향 범위를 유추할 수 있다'와 비슷하지만 이번 포인트는 '클래스 이름에서 형태, 기능, 역할을 유추할 수 있다'이다. 예를 들면, 다음과 같은 클래스가 있다면 어떨까?

-   title1
-   title2
-   title3

어느 타이틀이 어떤 역할을 할지 도저히 유추할 수 없다. 이 클래스 이름이 다믕과 같다면 어떨까?

-   page-title
-   section-title
-   sub-title

위와 같은 형태라면 CSS나 실제 표시된 내용을 보지 않더라도 어떤 역할을 담당하는지 대략 유추할 수 있다.

### 모듈 리팩터링

지금까지 모듈의 코드에서 개선할 포인트는 'bl_module'이라는 클래스였다. 앞에서 설명한 것과 같이, 만약 모듈이 늘어나 다음과 같은 클래스가 되었다고 가정해보자.

-   bl_module
-   bl_module2
-   bl_module3

이 경우에는 어떤 모듈이 어떤 형태나 기능을 하는지는 실제 코드를 봐야만 알 수 있다. 이런 상황은 그다지 바람직하지 않으므로 각 모듈에 맞춰 이름을 붙이는 것이 중요하다.

지금까지 리팩터링한 모듈의 형태를 다시 그림 2-14에 표시했다. 이런 화면돠 텍스트 블록을 가로로 나란히 늘어놓은 모듈을 일반적으로 '미디어(Media)'라고 부른다.

그러므로 'bl_module'이라는 클래스 이름은 'bl_media'로 바꿀 수 있다. 이외에 카드형 모듈이나 리스트형 모듈이 추가되는 경우에도 각각 다음과 같이 이름을 붙일 수 있다.

-   bl_media
-   bl_card
-   bl_list

이제 어떤 모듈인지 간단하게나마 유추할 수 있을 것이다.

```html
<article id="main" class="ly_cont">
    <div class="bl_media">
        <figure class="bl_media_image-wrapper">
            ⭐️
            <img src="#" alt="사진: 손에 든 스마트폰" />
        </figure>
        <div class="bl_media_body">
            ⭐️
            <h2 class="bl_media_title">
                ⭐️ 사용자를 고려한 설계로 만족스러운 체험을
            </h2>
            <p>
                웹사이트 설계는 제공하는 서비스나 퍼소나에 따라 달라집니다.
                서비스와 퍼소나에 맞춘 설계를 통해 방문자에게 스트레스를 주지
                않는 보다 나은 체험을 만들어 만족감을 높입니다. <br />
                우리는 고객의 사이트에 맞는 사용성을 고려하기 때문에 세심한
                분석과 의견 청취를 실시함으로써, 만족을 체험할 수 있는
                크리에이티브 및 테크놀로지를 설계하고 구현함으로써 지금까지는
                없던 기대를 뛰어넘는 사용자 체험을 제공합니다.
            </p>
            <h3 class="sub-title">퍼소나란?</h3>
            ⭐️
            <span>
                자사 상품, 서비스의 이상적/ 상징적인 고객 이미지를 말합니다.
                접근할 대상을 명확히 함으로써 효율적인 마케팅을 수행할 수
                있습니다.
            </span>
        </div>
    </div>
</article>
```

```css
.bl_media {
    display: flex;
    align-items: center;
    font-size: 16px;
    line-height: 1.5;
}
.bl_media_image-wrapper {
    flex: 1 1 25%;
    margin-right: 3.33333%;
}
.bl_media_image-wrapper img {
    width: 100%;
    vertical-align: top;
}
.bl_media_body {
    flex: 1 1 68.33333%;
}
.bl_media_title {
    margin-bottom: 10px;
    font-size: 18px;
    font-weight: bold;
}
.bl_media_body > span {
    color: #555;
    font-size: 14px;
}
.subTitle {
    margin-top: 10px;
    margin-bottom: 10px;
    font-size: 16px;
    border-bottom: 1px solid #555;
}
```

### 구체성과 범용성에서 모듈 이름을 고려한다.

모듈 이름에 관해 조금 더 깊이 생각해보자. 설명을 위해 여기에서만 '미디어 모듈은 about 페이지의 서비스 소개 부분에서 사용된다'고 가정하자. 이 모듈의 이름을 고려할 때 크게 다음과 같은 이름을 생각해볼 수 있다.

-   .bl_aboutService
-   .bl_aboutMedia
-   .bl_service
-   .bl_media
-   .bl_imgTitleText

필자가 이 중에서 가장 적절하다고 생각하는 것은 물론 '.bl_media'입니다. 그 이유는 다음과 같다.

-   이름에서 형태, 기능, 역할을 유추할 수 있다.
-   구체성과 범용성의 균형이 맞는다.

이 중에서 두 번쨰 항목인 '구체성과 범용성'에 관해 구체적으로 알아보자. 앞에서 에시든 모듈 이름의 경우 실은 위쪽에 있을수록 '구체성'이 강하고 아래쪽에 있을수록 '범용성'이 강해진다.

(반비례 관계구나....!)

이런 형태가 되는 이유는 무엇인지 그리고 .bl_media가 가장 적절하다고 생각한 이유가 무엇인지 위에서 부터 하나씩 순서대로 설명하겠다.

#### bl_aboutService

구체성이 가장 높은 것은 bl_aboutService이다. 그 이유는 'about'라는 단어와 'service'라는 단어를 모두 포함하고 있기 때문이다. 앞서 '이 모듈은 about 페이지의 서비스 소개 부분에서 사용한 것'을 전제로 했다. 이 이름은 그야말로 사용되는 상태에 착안해서 붙인 것이다.

단순하고 이해하기 쉬우나 거꾸로 말하면 'about' 페이지의 서비스 소개 부분 이외에는 사용할 수 없다'는 치명적인 약점이 있다. '사용할 수 없다'고 하더라도 HTML/CSS 사양의 제한이 있는 것은 아니므로 마음먹으면 다른 위치에서도 사용할 수 있다. 하지만 bl_aboutService라는 모듈이 연락처 페이지 안에 있는 상태는 어떻게 느껴지는가?

이것은 '결국 모듈 이름에 관계없이 어디서나 사용해도 좋다'는 의미가 된다. 그렇다면 'about'와 'service'라는 단어를 굳이 모듈에 포함시킨 의미가 사라지므로 혼란을 일으킨다. 뒤집어 말하면 'about 페이지의 서비스 소개 부분 이외에는 절대 사용할 수 없다'는 상황에서는 적절한 이름이라고 할 수 있다. 하지만 여러 사람이 함께 개발하는 과정에서 '그 위치가 아니면 절대 사용할 수 없다'는 상황 자체를 모두가 확실하게 기억하고 지키는 일은 어려울 것.

#### bl_aboutMedia

다음은 bl_aboutMedia이다. 이 이름도 결국 앞에서 설명한 것처럼 'about'라는 단어를 포함하는 한 'about 페이지가 아니면 사용할 수 없다'는 제약이 생기므로, 모듈 재사용성 고자ㅓㅇ에서 바람직한 이름은 아니다. 강하게 이야기하면 'service'라는 단어가 없는 만큼 '서비스 소개 이외의 위치에서도 사용할 수 있다'는 정도의 자유도는 늘어난다.

#### bl_service

이 이름에서는 'about'라는 단어가 사라지고 'service'만 남았다. 즉, 이 모듈의 이름은 페이지에 관계없이 서비스 소개 부분에 사용할 수 있음을 의미한다. 하지만 결국은 '미디어 모듈을 사용하는 위치는 서비스 소개 부분만이라고 한정할 수 없다'는 문제가 도사리고 있다.

물론, 개발 시에는 서비스 소개 위치에서만 사용할 수도 있다. 하지만 사이트를 공개한 뒤 운용하느 과정에서, 예를 들어, 새롭게 만든 페이지의 '특징 소개'(이 경우 자주 사용하는 영어 단어는 feature 등) 부분에서도 사용하고 싶을 수 있다. 이때 모듈의 이름이 bl_service인 상태에서는 그 이름과 사용되는 상황 사이에 괴리가 발생한다.

또한 '페이지 내 서비스 소개 부분에 사용한다'는 의미로 'bl_service'라는 이름을 붙이더라도 다른 사람은 '서비 [페이지]에 사용하는 것'이라고 오해할 수도 있다. 이 클래스 이름에서는 '페이지'인지 '위치'인지 판단할 수 없다. 따라서 범용성을 생각하면 이 또한 최적의 이름이라고 할 수 없다.

#### bl_media

필자가 생각하는 최적의 이름이다. 우선 'about'나 'service'라는 단어를 포함하지 않기 때문에 구체성이 단번에 낮아졌다. 즉, 어바우트 등의 특정한 페이지나 서비스 소개 등의 특정한 부분에 관계없이, 웹페이지 안의 어느 위치에서든 신경 쓰지 않고 이 모듈을 사용할 수 있게 된다.

또한 bl_media라는 모듈 이름은 이 절의 주제인 '클래스 이름에서 형태, 기능, 역할을 유추할 수 있다'는 점도 만족한다. 앞서 예시를 든 bl_aboutService나 bl_service의 경우에는 모듈 이름만 봐서는 이들이 어떤 형태인지 정확하게 유추할 수 없었다. 이에 비해 일반적으로 media라는 단어는 웹 업계에서 모듈의 이름으로 주로 사용하며 많은 사람들이 대부분 같은 것을 상상할 것이다.

웹사이트의 규모가 커지고 모듈 수가 증가할수록 '클래스 이름에서 형태, 기능, 역할을 유추할 수 있다'는 중요성은 늘어난다. 미디어(Media) 외에도 아코디언(Accordion)이나 슬라이더(Slider) 등 일반적으로 사용하는 UI이라면 좋지만, 때로는 아예 해당하지 않는 모듈도 나올 수 있을 것이다. 이런 경우에는 형태를 떠올릴 수 있는 이름을 사용하는 것이 좋다.

#### bl_imgTitleText

가장 마지막으로 구체성은 오나전히 배제하고 범용성에만 특화된 이름으로, 모듈 요소를 순서대로 열거한 것ㅇ디ㅏ. 앞서 설명한 내용이 반복되는 것 같지만 이런 이름은 다음과 같은 약점을 가진다.

-   클래스 이름에서 형태, 기능, 역할을 유추할 수 없다.
-   다른 모듈이 늘어날수록 구별이 어려워진다.

두 가지 약점 모두 치명적이므로 이름을 붙이는 방법으로는 권장하지 않는다.

재사용을 전제로 한 모듈에서는 필자는 결국 최적의 이름이 다음과 같은 특징을 갖는다고 생각한다.

1. 콘텍스트가 아니라 형태, 기능, 역할을 기반으로 만든다.
2. Media, Accordion, Slider 등 일반적인 호칭을 사용한다.

## 확장하기 쉽다.

마지막 포인트는 '확장하기 쉽다'이다. 웹사이트는 '공개하면 끝'이 아니라 공개한 후에도 계속 운영해야 하며, 그 과정에서 기존 페이지나 모듈에 대한 변경이 발생하는 일도 드물지 않다. 사실 처음부터 모든 변경을 완전히 파악하고 예측하기란 불가능하다. 그렇다면 페이지나 레이아웃, 모듈 등 각각의 CSS에 대해 '가능한 변경을 견딜 수 있도록' 설계하는 부분과 연결된다. 그렇기 때문에 '확장하기 쉽다'가 가장 마지막 포인트가 된다.

코드를 확장하기 쉬운 상태로 유지하면 추가 요구 사항이 있을 때도 하나의 셀렉터와 속성을 추가하는 것만으로 대응을 완료할 수 있는 경우가 많다. 확장성과 관련해 다음 두 가지 관점이 있다.

-   "확장하기 쉬운 클래스 설계"에 관해 먼저 "싱글 클래스 설계와 멀티 클래스 설계"의 개념을 알아야 하므로 이제까지의 모듈과는 별도로 새로운 모듈을 예로 들어 설명하겠다. 후자인 '적절한 상세도'에 관해서는 모듈 리팩터링 후 알아보자.

### 싱글 클래스와 멀티 클래스

-   어떤 모듈의 스타일이 조금만 다른 베리에이션(Variation)을 만든다.
-   혹은 상태의 변화를 구현한다.

위와 같은 경우 그 방법에 따라 크게 싱글 클래스 설계와 멀티 클래스 설계 두 가지로 나눌 수 있다. 싱글 클래스 설계만 간단히 말하면, HTML에 대한 모듈 클래스를 항상 하나로 연결하는 방법이다. 이에 비해 멀티 클래스 설계는 모듈에 관련된 클래스를 형태나 기능, 역할에 따라 적절하게 분할해서 HTML에 여러 모듈의 연결을 허용하는 설계 기법이다.

#### 싱글 클래스 설계

그림 2-16과 같은 두 종류의 버튼을 생각해보자.

```html
<a class="el_btnTheme" href="#">기본 버튼</a>
<a class="el_btnWarning" href="#">색이 다른 버튼</a>
```

```css
.el_btnTheme {
    display: inline-block;
    width: 300px;
    max-width: 100%;
    padding: 20px 10px;
    background-color: #e25c00;
    box-shadow: 0 3px 6px rgba(0, 0, 0, .16);
    color: #fff;
    font-size: 18px;
    line-height: 1.5;
    text-align: center;
    text-decoration: none;
    transition: .25s;
}
.el_btnWarning {
    display: inline-block;
    width: 300px;
    max-width: 100%
    padding: 20px 10px;
    background-color: #f1de00;
    box-shadow: 0 3px 6px rgba(0,0,0 .16);
    color: #222;
    font-size: 18px;
    line-height: 1.5;
    text-align: center;
    text-decoration: none;
    transition: .25s
}
```

앞에서 설명한 것처럼 HTML에 설정할 클래스는 각각 다음 중 하나이다.

-   el_btnTheme
-   el_btnWarning

보시다시피 HTML 측의 클래스 속성이 매우 깔끔하다. 하지만 CSS 축애소는 많은 코드가 중복되며 배리에이션 수가 늘어날수록 CSS가 비대화되는 단점을 갖고 있다.
실제 앞의 코드만 보더라도 background-color 와 color를 제외한 모든 코드가 el_btnTheme, el_btnWarning에서 완전히 동일하다.

CSS의 비대화를 피하기 위해 다음과 같이 그룹 셀렉터를 사용할 수도 있다.

```css
.el_btnTheme, .el_btnWarning {
    display: inline-block;
    width: 300px;
    max-width: 100%;
    padding: 20px 10px;
    box-shadow: 0 3px 6px rgba(0, 0, 0, .16);
    font-size: 18px;
    line-height: 1.5;
    text-align: center
    text-decoration: none;
    transition: .25s;
}
.el_btnTheme {
    background-color: #e25c00;
    color: #fff;
}
.el_btnWarning {
    background-color: #f1de00;
    color: #222;
}
```

이 책에서 설명할 영역에서 벗어나므로 자세히 설명하지는 않지만, 싱글 클래스 설계를 할 때에는 Sass의 Mixin이나 Extend 기능을 사용하면 보다 효과적으로 개발을 진행할 수 있다. 그로 인해 싱글 클래스 설계의 단점이 해소되었다고 생각할 수도 있지만, 실제 단점은 그것뿐 아니라, 모듈 확장에 대한 유연성이 낮다는 점이 싱글 클래스 설계가 가진 진짜 약점이라고 할 수 있을 것이다.

예를 들어, 운용 중에 다음과 같은 상황이 발생했다고 가정하자.

-   각 버튼의 박스 그림자가 없는 패턴
-   그림자는 있지만 문자 색상이 흑백 반전된 패턴(읽기 어려운 점은 차치하더라도)
-   그림자가 없고 문자 색상도 반전된 패턴

이런 요구가 발생하면 어떻게 될까?

싱글 클래스 설계는 스타일 수만큼 클래스를 준비해야 하므로 다음 코드와 같이 클래스 수가 급격하게 증가한다. (p 64 참고)

이것만으로 코드가 상당히 길어져 버렸다. 그룹 셀렉터가 오히려 역효과를 내는 느낌마저 든다. 결국 싱글 클래스 설계에서는 '기본 모듈에서 조금만 다른 파생 모듈을 만들고자'하는 경우라 할지라도 반드시 CSS도 수정해서 전용 클래스를 새로 만들어야만 한다. 낮은 유연성 때문이라도 최근의 CSS 설계에서는 다음에 멀티 클래스 설계가 주류를 이룬다.

#### 멀티 클래스 설계

앞에서의 원래 코드(두 종류 버튼만 있는 코드)를 멀티 클래스 설계로 바꿔 작성한 코드는 다음과 같다.

```html
<a class="el_btn hp_theme" href="#">기본 버튼</a>
<a class="el_btn hp_warning" href="#">색이 다른 버튼</a>
```

```css
.el_btn {
    display: inline-block;
    widht: 300px;
    max-width: 100%;
    padding: 20px 10px;
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16);
    font-size: 18px;
    line-height: 1.5;
    text-align: center;
    text-decoration: none;
    transition: 0.25s;
}
.hp_theme {
    background-color: #e25c00;
    color: #fff;
}
.hp_warning {
    background-color: #f1de00;
    color: #222;
}
```

HTML 클래스 속성으로 여러 값을 설정했다. 양쪽에서 공통으로 사용하는 el_btn 클래스가 버튼 모듈의 베이스가 되며 hp_theme와 hp_warning 클래스를 각각 추가해 배경 색상은 설정한다. 두 버튼의 베이스가 되는 el_btn 클래스는 싱글 클래스 설계에서 비대화를 회피하기 위해 [공통부분]을 추출해 별도로 기술하는 방법과 비슷하다. 사실 속성과 값은 완전히 동일하다.

```css
.el_btnTheme,
.el_btnWarning {
    display: inline-block;
    width: 300px;
    max-width: 100%;
    padding: 20px 10px;
    box-shadow: 0 3px 6px rgba(0, 0, 0, .16);
    font-size: 18px;
    line-height: 1.5;
    text-align: center;
    text-decoration: none:
    transition: .25s;
}
```

도리어 이 코드를 기본 클래스로 다시 분리하는 것이 멀티 클래스 설계의 기본 사고방식이다. 게다가 멀티 클래스 설계의 경우 여러 클래스를 덧붙이면서 '덮어쓰기'라는 개념도 생기므로 '주황색 배경 색상과 흰색 문자 색상을 버튼의 기본 클래스로 간주'할 수도 있다. 이 경우, 주황색 버튼에 class="el_btn hp_theme"과 같이 여러 클래스를 사용했던 것을 class="el_btn" 하나로 정리할 수 있다.

그 결과 다음 코드와 같이 HTML의 클래스 및 CSS 셀렉터를 하나씩 줄일 수 있다.

```html
<a class="el_btn" href="#">기본 버튼</a>
<a class="el_btn hp_warning" href="#">색이 다른 버튼</a>
```

```css
.el_btn {
    display: inline-block;
    width: 300px;
    max-width: 100%;
    padding: 20px 10px;
    background-color: #e25c00; /* 베이스 클래스 추가 */
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16);
    font-size: 18px;
    line-height: 1.5;
    text-align: center;
    text-decoration: none;
    transition: 0.25s;
}
.hp_warning {
    background-color: #f1de00;
    color: #222;
}
```

멀티 클래스 설계에서도 앞의 싱글 클래스 설계와 마찬가지와 마찬가지로 다음과 같은 요구 사항이 발생할 수 있다.

-   각 버튼의 박스 그림자가 없는 패턴
-   그림자는 있지만 문자 색상이 흑백 반전된 패턴
-   그림자가 없고 문자 색상도 반전된 패턴

이 경우에도 CSS는 단순한 상태를 유지한 채 구현할 수 있다.

P 67 참고

어떻습니까? 싱글 클래스 설계에서는 상당히 긴 코드를 추가했던 것에 비해, 멀티 클래스 설계에서는 극적으로 CSS 코드양을 줄일 수 있다. 하지만 HTML의 클래스에 여러 값이 붙어 있기 때문에 코드를 읽기 어려워진 것 또한 사실이므로 사람에 따라서는 복잡하게 느낄 수도 있다.

결국 이 부분에 관해서는 트레이드오프가 발생한다.

-   싱글 클래스 설계 --- HTML은 간단하지만 CSS는 그만큼 복잡해진다.
-   멀티 클래스 설계 --- HTML은 복잡하지만 CSS는 그만큼 간단해진다.

하지만 멀티 클래스 설계에는 단순함 혹은 복잡성과는 다른 가능성이 있다. 앞의 예시에서 구현한 .hp_textBlack이라는 클래스는 문자 색상을 검은색으로 설정하는 간단하고 범용적인 클래스 역할을 한다. 이는 버튼 이외의 대상에도 사용할 수 있기 때문에 다른 위치에서도 '이 부분의 문자 색상만 검은 색으로 만들고 싶다. '이 부분의 문자 색상만 흰색으로 만들고 싶다' 와 같은 불규칙한 상황에서도 HTML에 클래스를 하나 추가하는 것만으로 작업을 완료할 수 있다.

또한 운용 및 유지 보수에 있어서도 부가적인 혜택이 있다. 예를 들어, 클라이언트가 '이 부분의 텍스트를 흰색으로 만들고 싶다'고 한 경우 CSS를 편집할 필요 없이 해당 부붐의 HTML에 클래스를 추가하기만 하면 요구 사항을 만족시킬 수 있다.

웹 개발에 관해 잘 모르는 클라이언트에게 편집할 파일이 적다는 점은 큰 장점이며, 우리 개발자들에게 있어서도 클라이언트가 가급적 파일에 손을 대지 않는 것이 좋다. 멀티 클래스 설계는 그런 문제를 해결하는 데도 도움이 된다.

이 책에서 소개할 설계 기법은 다음과 같다.

-   OOCSS
-   SMACSS
-   BEM
-   PRECSS

이들은 모두 명명 방법이나 샘플, 규칙 정도의 차가 있기는 하나 기본적으로는 멀티 클래스 설계를 채용하고 있다.

### 모듈 리팩토링

싱글 클래스 설계와 멀티 글래스 설계에 관한 설명이 상당히 길어졌다. 이제 미디어 모듈로 돌아가보자. 우선 이 절에서는 확장에 관한 것을 살펴볼 예정이므로 리팩터링이 아니라 코드를 추가한다.

기존 클래스에 대해 무언가 변경을 추가해 덮어쓰기 위한 클래스를 '모디파이어(Modifier)라고 부른다. 멀티 클래스 절에서 사용한 'hp_textBlack'이나 'mb20(margin-bottom: 20px 적용)' 등과 같이 주로 한 가지 속성을 변경하기 위한 클래스를 '헬퍼 클래스(Helper class)' 또는 '유틸리티 클래스(Utility Class)'라고 부른다.

절 초반에 확장하기 쉬운 관점으로서 '확장용으로서 작성하는 클래스는 기능, 역할에 적절한 상세도와 영향 범위를 갖는다'라고 설명했다. 먼저 적절하지 않은 패턴부터 소개한다.

-   이미지와 텍스트 블록 치환
-   이미지와 텍스트 블록 사이의 여백 설정(원모듈은 이미지에 margin-right를 설정했으므로, 아무 조정도 하지 않으면 이미지와 텍스트 블록이 달라붙어 버린다)
-   텍스트를 오른쪽 정렬로 변경

CSS에서 필요한 코드는 각각 다음과 같다.

```css
.bl_media {
    display: flex;
    align-item: center;
    font-size: 16px;
    line-height: 1.5;
    /* 다음 행을 추가하고 싶음 */
    flex-direction: row-reverse;l
    text-align: right;
}
.bl_media_imageWrapper {
    flex: 1 1 25%;
    margin-right: 3.33333%
    /* 다음 행으로 덮어쓰고 싶음 */
    margin-right: 0;
}
.bl_media_body {
    flex: 1 1 68.33333%;
    /* 다음 행을 추가하고 싶음 */
    margin-right: 3.33333%;
}
```

위 코드를 그대로 사용하면 원래 이미지가 왼쪽 패턴에도 영향을 미치기 때문에, 좌우 반전을 시키고 싶다면 셀렉터를 분리해야 한다. 조정할 셀렉터는 세 개 이므로 각각에 대해 모디파이어를 만들어 본다. 자세한 내용을 3장에서 설명하겠다. PRECSS 모디파이어 작성 규칙은 '{원래 클래스 이름}\_{모디파이어 이름}'이며 rev는 'reverse'의 약자이다.

이번에 만든 세 개의 ㅁ되파이어에 대해 CSS로 스타일링을 하자.

```css
/* ,bl_media 스타일링에 이후 다음 코드 추가 */
.bl_media_rev {
    flex-direction: row-reverse;
    text-align: right;
}
.bl_media_imageWrapper_rev {
    margin-right: 0;
}
.bl_media_body_rev {
    margin-right: 3.33333%;
}
```

이것으로 우선 모듈을 좌우로 반전시키는 목적을 달성할 수 있다. 또다시 반복하는 설명이지만 이 모디파이어의 상세도는 적절하지 않다. 왜냐하면 좌우 반전을 구현하기 위해 세 개의 모디파이어를 HTML 측에 추가해야 한다.

이 세 개의 모디파이어를 각각 별도로 사용하는 것도 고려한다면 지금처럼 구현해도 문제가 없다. 하지만 여기에서의 좌우 반전은 그렇지 않고 반드시 세 개를 한 세트로 사용해야만 한다. 또한 세 개로 나눠져 있는 경우에는 구현 시 하나라도 누락되는 사태가 발생할 수 있다. 여러분뿐만 아니라 다른 엔지니어도 수정하는 웹사이트라면 더욱 그렇다. 이 상태를 개선하기 위해서는 모디파이어를 하나로 묶는 것이 좋다.

HTML, CSS 모두 다음과 같이 수정하자.

```html
<div class="bl_media bl_media_rev">
    <figure class="bl_media_imageWrapper">(생략)</figure>
    <div class="bl_media_body">(생략)</div>
</div>
```

```css
/* .bl_media 스타일링 이후 다음 코드 추가 */
.bl_media_rev {
    flex-direction: row-reverse;
    text-align: right;
}
.bl_media_rev .bl_media_imageWrapper {
    margin-right: 0;
}
.bl_media_rev .bl_media_body {
    margin-right: 3.33333%;
}
```

이와 같이 모디파이어를 붙이는 위치를 모듈 루트 요소와 묶어 CSS 측에서 손자 셀렉터를 사용함으로써, 좌우 반전을 시키고 싶은 부분은 루트 요소에 클래스 하나를 붙이는 것만으로 작업을 완료할 수 있다. 또한 이 방법은 데이터에서 '.bl_media_rev' 문자열을 검색하면, 좌우 반전에 관련된 코드가 모두 검색 결과에 표시되는 장점도 있다.

이처럼 '모디파이어를 붙이는 위치(작성하는 모디파이어 수)는 변경을 추가하는 요소의 숫자와 일치하는 것이 아니라, 제공할 기능(또는 역할)마다 하나씩 만든다'는 것이 모디파이어의 상세도 및 영향 범위를 적절히 유지하는 포인트이다.

또 한 가지 예로 그림 2-19와 같이 이미지에 테두리 선을 그리는 확장 패턴의 구현을 생각해보자.

그림 2-19 : 이미지에 테두리 선을 설정한 확장 패턴

이 예시에서는 방금 전까지와는 방법이 완전히 바뀌어 루트 요소에 모디파이어를 붙이는 방법은 권장하지 않는다.

```html
<div class="bl_media bl_media_imageBordered">
    <figure class="bl_media_imageWrapper">(생략)</figure>
</div>
```

'이미지에 테두리 선을 붙이고 싶은' 경우 변경 대상이 되는 요소는 이미지뿐이다. 그런데 루트 요소에 모디파이어를 붙이면 '이미지의 다른 자녀 요소를 모디파이어로 변경할 것 같은' 사실과 다른 예상을 할 수 있게 된다. 따라서 이 경우에는 변경 대상이 되는 자녀 요소에 직접 모디파이어를 붙이는 것이 바람직하다. 이것으로 모디파이어를 HTML에서 추가한 경우의 영향 범위도 예상하기 쉬워진다.

```html
<div class="bl_media">
    <figure class="bl_media_imageWrapper bl_media_imageWrapper_bordered">
        (생략)
    </figure>
</div>
```

```css
.bl_media_imageWrapper_bordered {
    padding: 2px;
    border: 1px solid #aaa;
}
```

위와 같이 '쉬운 확장성'을 보장하기 위해서는 멀티 클래스라는 점을 전제로 하고, 모디파이어를 만들 때도 상세도와 영향 범위를 확실하게 고려해 다음과 같은 상태를 구현하는 것이 이상적이다.

-   모디파이어 이름에서 영향 범위(여러 요소를 변경하는지, 한 요소만 변경하는지)를 예측할 수 있다.
-   하나의 모디파이어는 하나의 기능(또는 역할, 변경)과 과하거나 부족함이 없이 연결되어 있다.

### 너무 많은 모디파이어는 때로 혼란을 부른다.

지금까지 기본적으로 효율적이라 설명했던 멀티 클래스 설계 역시 마냥 좋아만 할 수 없는 부분도 당연히 존재한다. 예를 들어, 한 모듈에 대해 모디파이어를 10개 혹은 20개나 만드는 경우 어떤 모디파이어가 어떤 움직임을 하는지 파악하기 어려워 도리어 혼란을 야기하기도 한다. 그런 경우에는 다음 방법을 사용해 모디파이어 수를 줄이는 것을 검토해 보자.

-   단순한 덮어쓰기의 경우에는 헬퍼 클래스를 대신 사용할 수 있는지 검토한다.
-   모디파이어를 여러 개 붙인 것을 많이 사용하는 경우에는 새로운 모듈을 만들어 모디파이어들을 덮어쓴다.

## 2장 마무리

이상으로 "CSS 설계 실전과 여덟 가지 포인트"에 관해 긴 내용을 다루었다. 여기세어 소개한 여덟 가지 포인트는 결국 각 항목이 완전히 독립된 것이 아니라, 서로 조금씩 연관이 되어 있다.

하지만 모든 것을 한 번에 복합적으로 고려하려고 하면 'CSS는 어렵다.' 'CSS는 고려할 것이 많아 복잡하다.'와 같은 늪에 빠질 수 있다. 가급적 다른 포인트와의 관계를 의식하지 말고 각각의 포인트에 대해 '왜 이렇게 작성하는 것이 좋은가?'라는 점을 화실히 짚고 넘어가면 될 것이다.

3장에서 소개할 다양한 설계 기법에 관해서도, 결국 여기에서 설명한 여덟 가지 중 어딘가에 반드시 해당하는 규칙이 형태만 조금씩 바뀌어 등장할 뿐이므로, 지금 모든 것을 완벽하게 이해하지 않아도 괜찮다. 이 책을 읽어 가다가 어려운 부분이 있다면 기억을 되새기기 위해 이 장으로 돌아와서 확인하라. 이 여덟 가지 포인트에서 말하고자 하는 바를 납득할 수 있다면 여러분은 이미 CSS 설계의 비법을 몸에 익힌 것이다!
